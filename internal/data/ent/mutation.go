// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/nuanxinqing123/QLToolsV2/internal/data/ent/cdkey"
	"github.com/nuanxinqing123/QLToolsV2/internal/data/ent/env"
	"github.com/nuanxinqing123/QLToolsV2/internal/data/ent/envplugin"
	"github.com/nuanxinqing123/QLToolsV2/internal/data/ent/loginhistory"
	"github.com/nuanxinqing123/QLToolsV2/internal/data/ent/panel"
	"github.com/nuanxinqing123/QLToolsV2/internal/data/ent/plugin"
	"github.com/nuanxinqing123/QLToolsV2/internal/data/ent/pluginexecutionlog"
	"github.com/nuanxinqing123/QLToolsV2/internal/data/ent/predicate"
	"github.com/nuanxinqing123/QLToolsV2/internal/data/ent/user"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCdKey              = "CdKey"
	TypeEnv                = "Env"
	TypeEnvPlugin          = "EnvPlugin"
	TypeLoginHistory       = "LoginHistory"
	TypePanel              = "Panel"
	TypePlugin             = "Plugin"
	TypePluginExecutionLog = "PluginExecutionLog"
	TypeUser               = "User"
)

// CdKeyMutation represents an operation that mutates the CdKey nodes in the graph.
type CdKeyMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	key           *string
	count         *int32
	addcount      *int32
	is_enable     *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CdKey, error)
	predicates    []predicate.CdKey
}

var _ ent.Mutation = (*CdKeyMutation)(nil)

// cdkeyOption allows management of the mutation configuration using functional options.
type cdkeyOption func(*CdKeyMutation)

// newCdKeyMutation creates new mutation for the CdKey entity.
func newCdKeyMutation(c config, op Op, opts ...cdkeyOption) *CdKeyMutation {
	m := &CdKeyMutation{
		config:        c,
		op:            op,
		typ:           TypeCdKey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCdKeyID sets the ID field of the mutation.
func withCdKeyID(id int64) cdkeyOption {
	return func(m *CdKeyMutation) {
		var (
			err   error
			once  sync.Once
			value *CdKey
		)
		m.oldValue = func(ctx context.Context) (*CdKey, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CdKey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCdKey sets the old CdKey of the mutation.
func withCdKey(node *CdKey) cdkeyOption {
	return func(m *CdKeyMutation) {
		m.oldValue = func(context.Context) (*CdKey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CdKeyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CdKeyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CdKey entities.
func (m *CdKeyMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CdKeyMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CdKeyMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CdKey.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CdKeyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CdKeyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CdKey entity.
// If the CdKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CdKeyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CdKeyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CdKeyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CdKeyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CdKey entity.
// If the CdKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CdKeyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CdKeyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetKey sets the "key" field.
func (m *CdKeyMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *CdKeyMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the CdKey entity.
// If the CdKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CdKeyMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *CdKeyMutation) ResetKey() {
	m.key = nil
}

// SetCount sets the "count" field.
func (m *CdKeyMutation) SetCount(i int32) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *CdKeyMutation) Count() (r int32, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the CdKey entity.
// If the CdKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CdKeyMutation) OldCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *CdKeyMutation) AddCount(i int32) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *CdKeyMutation) AddedCount() (r int32, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCount resets all changes to the "count" field.
func (m *CdKeyMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
}

// SetIsEnable sets the "is_enable" field.
func (m *CdKeyMutation) SetIsEnable(b bool) {
	m.is_enable = &b
}

// IsEnable returns the value of the "is_enable" field in the mutation.
func (m *CdKeyMutation) IsEnable() (r bool, exists bool) {
	v := m.is_enable
	if v == nil {
		return
	}
	return *v, true
}

// OldIsEnable returns the old "is_enable" field's value of the CdKey entity.
// If the CdKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CdKeyMutation) OldIsEnable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsEnable: %w", err)
	}
	return oldValue.IsEnable, nil
}

// ResetIsEnable resets all changes to the "is_enable" field.
func (m *CdKeyMutation) ResetIsEnable() {
	m.is_enable = nil
}

// Where appends a list predicates to the CdKeyMutation builder.
func (m *CdKeyMutation) Where(ps ...predicate.CdKey) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CdKeyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CdKeyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CdKey, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CdKeyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CdKeyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CdKey).
func (m *CdKeyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CdKeyMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, cdkey.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, cdkey.FieldUpdatedAt)
	}
	if m.key != nil {
		fields = append(fields, cdkey.FieldKey)
	}
	if m.count != nil {
		fields = append(fields, cdkey.FieldCount)
	}
	if m.is_enable != nil {
		fields = append(fields, cdkey.FieldIsEnable)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CdKeyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cdkey.FieldCreatedAt:
		return m.CreatedAt()
	case cdkey.FieldUpdatedAt:
		return m.UpdatedAt()
	case cdkey.FieldKey:
		return m.Key()
	case cdkey.FieldCount:
		return m.Count()
	case cdkey.FieldIsEnable:
		return m.IsEnable()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CdKeyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cdkey.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cdkey.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cdkey.FieldKey:
		return m.OldKey(ctx)
	case cdkey.FieldCount:
		return m.OldCount(ctx)
	case cdkey.FieldIsEnable:
		return m.OldIsEnable(ctx)
	}
	return nil, fmt.Errorf("unknown CdKey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CdKeyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cdkey.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cdkey.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cdkey.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case cdkey.FieldCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	case cdkey.FieldIsEnable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsEnable(v)
		return nil
	}
	return fmt.Errorf("unknown CdKey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CdKeyMutation) AddedFields() []string {
	var fields []string
	if m.addcount != nil {
		fields = append(fields, cdkey.FieldCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CdKeyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cdkey.FieldCount:
		return m.AddedCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CdKeyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cdkey.FieldCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	}
	return fmt.Errorf("unknown CdKey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CdKeyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CdKeyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CdKeyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CdKey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CdKeyMutation) ResetField(name string) error {
	switch name {
	case cdkey.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cdkey.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cdkey.FieldKey:
		m.ResetKey()
		return nil
	case cdkey.FieldCount:
		m.ResetCount()
		return nil
	case cdkey.FieldIsEnable:
		m.ResetIsEnable()
		return nil
	}
	return fmt.Errorf("unknown CdKey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CdKeyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CdKeyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CdKeyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CdKeyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CdKeyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CdKeyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CdKeyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CdKey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CdKeyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CdKey edge %s", name)
}

// EnvMutation represents an operation that mutates the Env nodes in the graph.
type EnvMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	created_at         *time.Time
	updated_at         *time.Time
	name               *string
	remarks            *string
	quantity           *int32
	addquantity        *int32
	regex              *string
	mode               *int32
	addmode            *int32
	regex_update       *string
	is_auto_env_enable *bool
	enable_key         *bool
	cdk_limit          *int32
	addcdk_limit       *int32
	is_prompt          *bool
	prompt_level       *string
	prompt_content     *string
	is_enable          *bool
	clearedFields      map[string]struct{}
	panels             map[int64]struct{}
	removedpanels      map[int64]struct{}
	clearedpanels      bool
	env_plugins        map[int64]struct{}
	removedenv_plugins map[int64]struct{}
	clearedenv_plugins bool
	done               bool
	oldValue           func(context.Context) (*Env, error)
	predicates         []predicate.Env
}

var _ ent.Mutation = (*EnvMutation)(nil)

// envOption allows management of the mutation configuration using functional options.
type envOption func(*EnvMutation)

// newEnvMutation creates new mutation for the Env entity.
func newEnvMutation(c config, op Op, opts ...envOption) *EnvMutation {
	m := &EnvMutation{
		config:        c,
		op:            op,
		typ:           TypeEnv,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnvID sets the ID field of the mutation.
func withEnvID(id int64) envOption {
	return func(m *EnvMutation) {
		var (
			err   error
			once  sync.Once
			value *Env
		)
		m.oldValue = func(ctx context.Context) (*Env, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Env.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnv sets the old Env of the mutation.
func withEnv(node *Env) envOption {
	return func(m *EnvMutation) {
		m.oldValue = func(context.Context) (*Env, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnvMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnvMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Env entities.
func (m *EnvMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnvMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnvMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Env.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EnvMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EnvMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Env entity.
// If the Env object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EnvMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EnvMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EnvMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Env entity.
// If the Env object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EnvMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *EnvMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EnvMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Env entity.
// If the Env object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EnvMutation) ResetName() {
	m.name = nil
}

// SetRemarks sets the "remarks" field.
func (m *EnvMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the value of the "remarks" field in the mutation.
func (m *EnvMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old "remarks" field's value of the Env entity.
// If the Env object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvMutation) OldRemarks(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ClearRemarks clears the value of the "remarks" field.
func (m *EnvMutation) ClearRemarks() {
	m.remarks = nil
	m.clearedFields[env.FieldRemarks] = struct{}{}
}

// RemarksCleared returns if the "remarks" field was cleared in this mutation.
func (m *EnvMutation) RemarksCleared() bool {
	_, ok := m.clearedFields[env.FieldRemarks]
	return ok
}

// ResetRemarks resets all changes to the "remarks" field.
func (m *EnvMutation) ResetRemarks() {
	m.remarks = nil
	delete(m.clearedFields, env.FieldRemarks)
}

// SetQuantity sets the "quantity" field.
func (m *EnvMutation) SetQuantity(i int32) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *EnvMutation) Quantity() (r int32, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the Env entity.
// If the Env object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvMutation) OldQuantity(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *EnvMutation) AddQuantity(i int32) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *EnvMutation) AddedQuantity() (r int32, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *EnvMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetRegex sets the "regex" field.
func (m *EnvMutation) SetRegex(s string) {
	m.regex = &s
}

// Regex returns the value of the "regex" field in the mutation.
func (m *EnvMutation) Regex() (r string, exists bool) {
	v := m.regex
	if v == nil {
		return
	}
	return *v, true
}

// OldRegex returns the old "regex" field's value of the Env entity.
// If the Env object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvMutation) OldRegex(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegex: %w", err)
	}
	return oldValue.Regex, nil
}

// ClearRegex clears the value of the "regex" field.
func (m *EnvMutation) ClearRegex() {
	m.regex = nil
	m.clearedFields[env.FieldRegex] = struct{}{}
}

// RegexCleared returns if the "regex" field was cleared in this mutation.
func (m *EnvMutation) RegexCleared() bool {
	_, ok := m.clearedFields[env.FieldRegex]
	return ok
}

// ResetRegex resets all changes to the "regex" field.
func (m *EnvMutation) ResetRegex() {
	m.regex = nil
	delete(m.clearedFields, env.FieldRegex)
}

// SetMode sets the "mode" field.
func (m *EnvMutation) SetMode(i int32) {
	m.mode = &i
	m.addmode = nil
}

// Mode returns the value of the "mode" field in the mutation.
func (m *EnvMutation) Mode() (r int32, exists bool) {
	v := m.mode
	if v == nil {
		return
	}
	return *v, true
}

// OldMode returns the old "mode" field's value of the Env entity.
// If the Env object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvMutation) OldMode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMode: %w", err)
	}
	return oldValue.Mode, nil
}

// AddMode adds i to the "mode" field.
func (m *EnvMutation) AddMode(i int32) {
	if m.addmode != nil {
		*m.addmode += i
	} else {
		m.addmode = &i
	}
}

// AddedMode returns the value that was added to the "mode" field in this mutation.
func (m *EnvMutation) AddedMode() (r int32, exists bool) {
	v := m.addmode
	if v == nil {
		return
	}
	return *v, true
}

// ResetMode resets all changes to the "mode" field.
func (m *EnvMutation) ResetMode() {
	m.mode = nil
	m.addmode = nil
}

// SetRegexUpdate sets the "regex_update" field.
func (m *EnvMutation) SetRegexUpdate(s string) {
	m.regex_update = &s
}

// RegexUpdate returns the value of the "regex_update" field in the mutation.
func (m *EnvMutation) RegexUpdate() (r string, exists bool) {
	v := m.regex_update
	if v == nil {
		return
	}
	return *v, true
}

// OldRegexUpdate returns the old "regex_update" field's value of the Env entity.
// If the Env object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvMutation) OldRegexUpdate(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegexUpdate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegexUpdate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegexUpdate: %w", err)
	}
	return oldValue.RegexUpdate, nil
}

// ClearRegexUpdate clears the value of the "regex_update" field.
func (m *EnvMutation) ClearRegexUpdate() {
	m.regex_update = nil
	m.clearedFields[env.FieldRegexUpdate] = struct{}{}
}

// RegexUpdateCleared returns if the "regex_update" field was cleared in this mutation.
func (m *EnvMutation) RegexUpdateCleared() bool {
	_, ok := m.clearedFields[env.FieldRegexUpdate]
	return ok
}

// ResetRegexUpdate resets all changes to the "regex_update" field.
func (m *EnvMutation) ResetRegexUpdate() {
	m.regex_update = nil
	delete(m.clearedFields, env.FieldRegexUpdate)
}

// SetIsAutoEnvEnable sets the "is_auto_env_enable" field.
func (m *EnvMutation) SetIsAutoEnvEnable(b bool) {
	m.is_auto_env_enable = &b
}

// IsAutoEnvEnable returns the value of the "is_auto_env_enable" field in the mutation.
func (m *EnvMutation) IsAutoEnvEnable() (r bool, exists bool) {
	v := m.is_auto_env_enable
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAutoEnvEnable returns the old "is_auto_env_enable" field's value of the Env entity.
// If the Env object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvMutation) OldIsAutoEnvEnable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAutoEnvEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAutoEnvEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAutoEnvEnable: %w", err)
	}
	return oldValue.IsAutoEnvEnable, nil
}

// ResetIsAutoEnvEnable resets all changes to the "is_auto_env_enable" field.
func (m *EnvMutation) ResetIsAutoEnvEnable() {
	m.is_auto_env_enable = nil
}

// SetEnableKey sets the "enable_key" field.
func (m *EnvMutation) SetEnableKey(b bool) {
	m.enable_key = &b
}

// EnableKey returns the value of the "enable_key" field in the mutation.
func (m *EnvMutation) EnableKey() (r bool, exists bool) {
	v := m.enable_key
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableKey returns the old "enable_key" field's value of the Env entity.
// If the Env object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvMutation) OldEnableKey(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableKey: %w", err)
	}
	return oldValue.EnableKey, nil
}

// ResetEnableKey resets all changes to the "enable_key" field.
func (m *EnvMutation) ResetEnableKey() {
	m.enable_key = nil
}

// SetCdkLimit sets the "cdk_limit" field.
func (m *EnvMutation) SetCdkLimit(i int32) {
	m.cdk_limit = &i
	m.addcdk_limit = nil
}

// CdkLimit returns the value of the "cdk_limit" field in the mutation.
func (m *EnvMutation) CdkLimit() (r int32, exists bool) {
	v := m.cdk_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldCdkLimit returns the old "cdk_limit" field's value of the Env entity.
// If the Env object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvMutation) OldCdkLimit(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCdkLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCdkLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCdkLimit: %w", err)
	}
	return oldValue.CdkLimit, nil
}

// AddCdkLimit adds i to the "cdk_limit" field.
func (m *EnvMutation) AddCdkLimit(i int32) {
	if m.addcdk_limit != nil {
		*m.addcdk_limit += i
	} else {
		m.addcdk_limit = &i
	}
}

// AddedCdkLimit returns the value that was added to the "cdk_limit" field in this mutation.
func (m *EnvMutation) AddedCdkLimit() (r int32, exists bool) {
	v := m.addcdk_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetCdkLimit resets all changes to the "cdk_limit" field.
func (m *EnvMutation) ResetCdkLimit() {
	m.cdk_limit = nil
	m.addcdk_limit = nil
}

// SetIsPrompt sets the "is_prompt" field.
func (m *EnvMutation) SetIsPrompt(b bool) {
	m.is_prompt = &b
}

// IsPrompt returns the value of the "is_prompt" field in the mutation.
func (m *EnvMutation) IsPrompt() (r bool, exists bool) {
	v := m.is_prompt
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPrompt returns the old "is_prompt" field's value of the Env entity.
// If the Env object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvMutation) OldIsPrompt(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPrompt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPrompt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPrompt: %w", err)
	}
	return oldValue.IsPrompt, nil
}

// ResetIsPrompt resets all changes to the "is_prompt" field.
func (m *EnvMutation) ResetIsPrompt() {
	m.is_prompt = nil
}

// SetPromptLevel sets the "prompt_level" field.
func (m *EnvMutation) SetPromptLevel(s string) {
	m.prompt_level = &s
}

// PromptLevel returns the value of the "prompt_level" field in the mutation.
func (m *EnvMutation) PromptLevel() (r string, exists bool) {
	v := m.prompt_level
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptLevel returns the old "prompt_level" field's value of the Env entity.
// If the Env object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvMutation) OldPromptLevel(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptLevel: %w", err)
	}
	return oldValue.PromptLevel, nil
}

// ClearPromptLevel clears the value of the "prompt_level" field.
func (m *EnvMutation) ClearPromptLevel() {
	m.prompt_level = nil
	m.clearedFields[env.FieldPromptLevel] = struct{}{}
}

// PromptLevelCleared returns if the "prompt_level" field was cleared in this mutation.
func (m *EnvMutation) PromptLevelCleared() bool {
	_, ok := m.clearedFields[env.FieldPromptLevel]
	return ok
}

// ResetPromptLevel resets all changes to the "prompt_level" field.
func (m *EnvMutation) ResetPromptLevel() {
	m.prompt_level = nil
	delete(m.clearedFields, env.FieldPromptLevel)
}

// SetPromptContent sets the "prompt_content" field.
func (m *EnvMutation) SetPromptContent(s string) {
	m.prompt_content = &s
}

// PromptContent returns the value of the "prompt_content" field in the mutation.
func (m *EnvMutation) PromptContent() (r string, exists bool) {
	v := m.prompt_content
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptContent returns the old "prompt_content" field's value of the Env entity.
// If the Env object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvMutation) OldPromptContent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptContent: %w", err)
	}
	return oldValue.PromptContent, nil
}

// ClearPromptContent clears the value of the "prompt_content" field.
func (m *EnvMutation) ClearPromptContent() {
	m.prompt_content = nil
	m.clearedFields[env.FieldPromptContent] = struct{}{}
}

// PromptContentCleared returns if the "prompt_content" field was cleared in this mutation.
func (m *EnvMutation) PromptContentCleared() bool {
	_, ok := m.clearedFields[env.FieldPromptContent]
	return ok
}

// ResetPromptContent resets all changes to the "prompt_content" field.
func (m *EnvMutation) ResetPromptContent() {
	m.prompt_content = nil
	delete(m.clearedFields, env.FieldPromptContent)
}

// SetIsEnable sets the "is_enable" field.
func (m *EnvMutation) SetIsEnable(b bool) {
	m.is_enable = &b
}

// IsEnable returns the value of the "is_enable" field in the mutation.
func (m *EnvMutation) IsEnable() (r bool, exists bool) {
	v := m.is_enable
	if v == nil {
		return
	}
	return *v, true
}

// OldIsEnable returns the old "is_enable" field's value of the Env entity.
// If the Env object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvMutation) OldIsEnable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsEnable: %w", err)
	}
	return oldValue.IsEnable, nil
}

// ResetIsEnable resets all changes to the "is_enable" field.
func (m *EnvMutation) ResetIsEnable() {
	m.is_enable = nil
}

// AddPanelIDs adds the "panels" edge to the Panel entity by ids.
func (m *EnvMutation) AddPanelIDs(ids ...int64) {
	if m.panels == nil {
		m.panels = make(map[int64]struct{})
	}
	for i := range ids {
		m.panels[ids[i]] = struct{}{}
	}
}

// ClearPanels clears the "panels" edge to the Panel entity.
func (m *EnvMutation) ClearPanels() {
	m.clearedpanels = true
}

// PanelsCleared reports if the "panels" edge to the Panel entity was cleared.
func (m *EnvMutation) PanelsCleared() bool {
	return m.clearedpanels
}

// RemovePanelIDs removes the "panels" edge to the Panel entity by IDs.
func (m *EnvMutation) RemovePanelIDs(ids ...int64) {
	if m.removedpanels == nil {
		m.removedpanels = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.panels, ids[i])
		m.removedpanels[ids[i]] = struct{}{}
	}
}

// RemovedPanels returns the removed IDs of the "panels" edge to the Panel entity.
func (m *EnvMutation) RemovedPanelsIDs() (ids []int64) {
	for id := range m.removedpanels {
		ids = append(ids, id)
	}
	return
}

// PanelsIDs returns the "panels" edge IDs in the mutation.
func (m *EnvMutation) PanelsIDs() (ids []int64) {
	for id := range m.panels {
		ids = append(ids, id)
	}
	return
}

// ResetPanels resets all changes to the "panels" edge.
func (m *EnvMutation) ResetPanels() {
	m.panels = nil
	m.clearedpanels = false
	m.removedpanels = nil
}

// AddEnvPluginIDs adds the "env_plugins" edge to the EnvPlugin entity by ids.
func (m *EnvMutation) AddEnvPluginIDs(ids ...int64) {
	if m.env_plugins == nil {
		m.env_plugins = make(map[int64]struct{})
	}
	for i := range ids {
		m.env_plugins[ids[i]] = struct{}{}
	}
}

// ClearEnvPlugins clears the "env_plugins" edge to the EnvPlugin entity.
func (m *EnvMutation) ClearEnvPlugins() {
	m.clearedenv_plugins = true
}

// EnvPluginsCleared reports if the "env_plugins" edge to the EnvPlugin entity was cleared.
func (m *EnvMutation) EnvPluginsCleared() bool {
	return m.clearedenv_plugins
}

// RemoveEnvPluginIDs removes the "env_plugins" edge to the EnvPlugin entity by IDs.
func (m *EnvMutation) RemoveEnvPluginIDs(ids ...int64) {
	if m.removedenv_plugins == nil {
		m.removedenv_plugins = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.env_plugins, ids[i])
		m.removedenv_plugins[ids[i]] = struct{}{}
	}
}

// RemovedEnvPlugins returns the removed IDs of the "env_plugins" edge to the EnvPlugin entity.
func (m *EnvMutation) RemovedEnvPluginsIDs() (ids []int64) {
	for id := range m.removedenv_plugins {
		ids = append(ids, id)
	}
	return
}

// EnvPluginsIDs returns the "env_plugins" edge IDs in the mutation.
func (m *EnvMutation) EnvPluginsIDs() (ids []int64) {
	for id := range m.env_plugins {
		ids = append(ids, id)
	}
	return
}

// ResetEnvPlugins resets all changes to the "env_plugins" edge.
func (m *EnvMutation) ResetEnvPlugins() {
	m.env_plugins = nil
	m.clearedenv_plugins = false
	m.removedenv_plugins = nil
}

// Where appends a list predicates to the EnvMutation builder.
func (m *EnvMutation) Where(ps ...predicate.Env) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EnvMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EnvMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Env, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EnvMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EnvMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Env).
func (m *EnvMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnvMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, env.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, env.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, env.FieldName)
	}
	if m.remarks != nil {
		fields = append(fields, env.FieldRemarks)
	}
	if m.quantity != nil {
		fields = append(fields, env.FieldQuantity)
	}
	if m.regex != nil {
		fields = append(fields, env.FieldRegex)
	}
	if m.mode != nil {
		fields = append(fields, env.FieldMode)
	}
	if m.regex_update != nil {
		fields = append(fields, env.FieldRegexUpdate)
	}
	if m.is_auto_env_enable != nil {
		fields = append(fields, env.FieldIsAutoEnvEnable)
	}
	if m.enable_key != nil {
		fields = append(fields, env.FieldEnableKey)
	}
	if m.cdk_limit != nil {
		fields = append(fields, env.FieldCdkLimit)
	}
	if m.is_prompt != nil {
		fields = append(fields, env.FieldIsPrompt)
	}
	if m.prompt_level != nil {
		fields = append(fields, env.FieldPromptLevel)
	}
	if m.prompt_content != nil {
		fields = append(fields, env.FieldPromptContent)
	}
	if m.is_enable != nil {
		fields = append(fields, env.FieldIsEnable)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnvMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case env.FieldCreatedAt:
		return m.CreatedAt()
	case env.FieldUpdatedAt:
		return m.UpdatedAt()
	case env.FieldName:
		return m.Name()
	case env.FieldRemarks:
		return m.Remarks()
	case env.FieldQuantity:
		return m.Quantity()
	case env.FieldRegex:
		return m.Regex()
	case env.FieldMode:
		return m.Mode()
	case env.FieldRegexUpdate:
		return m.RegexUpdate()
	case env.FieldIsAutoEnvEnable:
		return m.IsAutoEnvEnable()
	case env.FieldEnableKey:
		return m.EnableKey()
	case env.FieldCdkLimit:
		return m.CdkLimit()
	case env.FieldIsPrompt:
		return m.IsPrompt()
	case env.FieldPromptLevel:
		return m.PromptLevel()
	case env.FieldPromptContent:
		return m.PromptContent()
	case env.FieldIsEnable:
		return m.IsEnable()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnvMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case env.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case env.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case env.FieldName:
		return m.OldName(ctx)
	case env.FieldRemarks:
		return m.OldRemarks(ctx)
	case env.FieldQuantity:
		return m.OldQuantity(ctx)
	case env.FieldRegex:
		return m.OldRegex(ctx)
	case env.FieldMode:
		return m.OldMode(ctx)
	case env.FieldRegexUpdate:
		return m.OldRegexUpdate(ctx)
	case env.FieldIsAutoEnvEnable:
		return m.OldIsAutoEnvEnable(ctx)
	case env.FieldEnableKey:
		return m.OldEnableKey(ctx)
	case env.FieldCdkLimit:
		return m.OldCdkLimit(ctx)
	case env.FieldIsPrompt:
		return m.OldIsPrompt(ctx)
	case env.FieldPromptLevel:
		return m.OldPromptLevel(ctx)
	case env.FieldPromptContent:
		return m.OldPromptContent(ctx)
	case env.FieldIsEnable:
		return m.OldIsEnable(ctx)
	}
	return nil, fmt.Errorf("unknown Env field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnvMutation) SetField(name string, value ent.Value) error {
	switch name {
	case env.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case env.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case env.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case env.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case env.FieldQuantity:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case env.FieldRegex:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegex(v)
		return nil
	case env.FieldMode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMode(v)
		return nil
	case env.FieldRegexUpdate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegexUpdate(v)
		return nil
	case env.FieldIsAutoEnvEnable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAutoEnvEnable(v)
		return nil
	case env.FieldEnableKey:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableKey(v)
		return nil
	case env.FieldCdkLimit:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCdkLimit(v)
		return nil
	case env.FieldIsPrompt:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPrompt(v)
		return nil
	case env.FieldPromptLevel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptLevel(v)
		return nil
	case env.FieldPromptContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptContent(v)
		return nil
	case env.FieldIsEnable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsEnable(v)
		return nil
	}
	return fmt.Errorf("unknown Env field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnvMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, env.FieldQuantity)
	}
	if m.addmode != nil {
		fields = append(fields, env.FieldMode)
	}
	if m.addcdk_limit != nil {
		fields = append(fields, env.FieldCdkLimit)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnvMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case env.FieldQuantity:
		return m.AddedQuantity()
	case env.FieldMode:
		return m.AddedMode()
	case env.FieldCdkLimit:
		return m.AddedCdkLimit()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnvMutation) AddField(name string, value ent.Value) error {
	switch name {
	case env.FieldQuantity:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	case env.FieldMode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMode(v)
		return nil
	case env.FieldCdkLimit:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCdkLimit(v)
		return nil
	}
	return fmt.Errorf("unknown Env numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnvMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(env.FieldRemarks) {
		fields = append(fields, env.FieldRemarks)
	}
	if m.FieldCleared(env.FieldRegex) {
		fields = append(fields, env.FieldRegex)
	}
	if m.FieldCleared(env.FieldRegexUpdate) {
		fields = append(fields, env.FieldRegexUpdate)
	}
	if m.FieldCleared(env.FieldPromptLevel) {
		fields = append(fields, env.FieldPromptLevel)
	}
	if m.FieldCleared(env.FieldPromptContent) {
		fields = append(fields, env.FieldPromptContent)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnvMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnvMutation) ClearField(name string) error {
	switch name {
	case env.FieldRemarks:
		m.ClearRemarks()
		return nil
	case env.FieldRegex:
		m.ClearRegex()
		return nil
	case env.FieldRegexUpdate:
		m.ClearRegexUpdate()
		return nil
	case env.FieldPromptLevel:
		m.ClearPromptLevel()
		return nil
	case env.FieldPromptContent:
		m.ClearPromptContent()
		return nil
	}
	return fmt.Errorf("unknown Env nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnvMutation) ResetField(name string) error {
	switch name {
	case env.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case env.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case env.FieldName:
		m.ResetName()
		return nil
	case env.FieldRemarks:
		m.ResetRemarks()
		return nil
	case env.FieldQuantity:
		m.ResetQuantity()
		return nil
	case env.FieldRegex:
		m.ResetRegex()
		return nil
	case env.FieldMode:
		m.ResetMode()
		return nil
	case env.FieldRegexUpdate:
		m.ResetRegexUpdate()
		return nil
	case env.FieldIsAutoEnvEnable:
		m.ResetIsAutoEnvEnable()
		return nil
	case env.FieldEnableKey:
		m.ResetEnableKey()
		return nil
	case env.FieldCdkLimit:
		m.ResetCdkLimit()
		return nil
	case env.FieldIsPrompt:
		m.ResetIsPrompt()
		return nil
	case env.FieldPromptLevel:
		m.ResetPromptLevel()
		return nil
	case env.FieldPromptContent:
		m.ResetPromptContent()
		return nil
	case env.FieldIsEnable:
		m.ResetIsEnable()
		return nil
	}
	return fmt.Errorf("unknown Env field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnvMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.panels != nil {
		edges = append(edges, env.EdgePanels)
	}
	if m.env_plugins != nil {
		edges = append(edges, env.EdgeEnvPlugins)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnvMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case env.EdgePanels:
		ids := make([]ent.Value, 0, len(m.panels))
		for id := range m.panels {
			ids = append(ids, id)
		}
		return ids
	case env.EdgeEnvPlugins:
		ids := make([]ent.Value, 0, len(m.env_plugins))
		for id := range m.env_plugins {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnvMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedpanels != nil {
		edges = append(edges, env.EdgePanels)
	}
	if m.removedenv_plugins != nil {
		edges = append(edges, env.EdgeEnvPlugins)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnvMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case env.EdgePanels:
		ids := make([]ent.Value, 0, len(m.removedpanels))
		for id := range m.removedpanels {
			ids = append(ids, id)
		}
		return ids
	case env.EdgeEnvPlugins:
		ids := make([]ent.Value, 0, len(m.removedenv_plugins))
		for id := range m.removedenv_plugins {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnvMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpanels {
		edges = append(edges, env.EdgePanels)
	}
	if m.clearedenv_plugins {
		edges = append(edges, env.EdgeEnvPlugins)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnvMutation) EdgeCleared(name string) bool {
	switch name {
	case env.EdgePanels:
		return m.clearedpanels
	case env.EdgeEnvPlugins:
		return m.clearedenv_plugins
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnvMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Env unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnvMutation) ResetEdge(name string) error {
	switch name {
	case env.EdgePanels:
		m.ResetPanels()
		return nil
	case env.EdgeEnvPlugins:
		m.ResetEnvPlugins()
		return nil
	}
	return fmt.Errorf("unknown Env edge %s", name)
}

// EnvPluginMutation represents an operation that mutates the EnvPlugin nodes in the graph.
type EnvPluginMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	created_at         *time.Time
	updated_at         *time.Time
	is_enable          *bool
	execution_order    *int32
	addexecution_order *int32
	_config            *string
	clearedFields      map[string]struct{}
	env                *int64
	clearedenv         bool
	plugin             *int64
	clearedplugin      bool
	done               bool
	oldValue           func(context.Context) (*EnvPlugin, error)
	predicates         []predicate.EnvPlugin
}

var _ ent.Mutation = (*EnvPluginMutation)(nil)

// envpluginOption allows management of the mutation configuration using functional options.
type envpluginOption func(*EnvPluginMutation)

// newEnvPluginMutation creates new mutation for the EnvPlugin entity.
func newEnvPluginMutation(c config, op Op, opts ...envpluginOption) *EnvPluginMutation {
	m := &EnvPluginMutation{
		config:        c,
		op:            op,
		typ:           TypeEnvPlugin,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnvPluginID sets the ID field of the mutation.
func withEnvPluginID(id int64) envpluginOption {
	return func(m *EnvPluginMutation) {
		var (
			err   error
			once  sync.Once
			value *EnvPlugin
		)
		m.oldValue = func(ctx context.Context) (*EnvPlugin, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EnvPlugin.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnvPlugin sets the old EnvPlugin of the mutation.
func withEnvPlugin(node *EnvPlugin) envpluginOption {
	return func(m *EnvPluginMutation) {
		m.oldValue = func(context.Context) (*EnvPlugin, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnvPluginMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnvPluginMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EnvPlugin entities.
func (m *EnvPluginMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnvPluginMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnvPluginMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EnvPlugin.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EnvPluginMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EnvPluginMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EnvPlugin entity.
// If the EnvPlugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvPluginMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EnvPluginMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EnvPluginMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EnvPluginMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EnvPlugin entity.
// If the EnvPlugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvPluginMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EnvPluginMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEnvID sets the "env_id" field.
func (m *EnvPluginMutation) SetEnvID(i int64) {
	m.env = &i
}

// EnvID returns the value of the "env_id" field in the mutation.
func (m *EnvPluginMutation) EnvID() (r int64, exists bool) {
	v := m.env
	if v == nil {
		return
	}
	return *v, true
}

// OldEnvID returns the old "env_id" field's value of the EnvPlugin entity.
// If the EnvPlugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvPluginMutation) OldEnvID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnvID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnvID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnvID: %w", err)
	}
	return oldValue.EnvID, nil
}

// ResetEnvID resets all changes to the "env_id" field.
func (m *EnvPluginMutation) ResetEnvID() {
	m.env = nil
}

// SetPluginID sets the "plugin_id" field.
func (m *EnvPluginMutation) SetPluginID(i int64) {
	m.plugin = &i
}

// PluginID returns the value of the "plugin_id" field in the mutation.
func (m *EnvPluginMutation) PluginID() (r int64, exists bool) {
	v := m.plugin
	if v == nil {
		return
	}
	return *v, true
}

// OldPluginID returns the old "plugin_id" field's value of the EnvPlugin entity.
// If the EnvPlugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvPluginMutation) OldPluginID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPluginID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPluginID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPluginID: %w", err)
	}
	return oldValue.PluginID, nil
}

// ResetPluginID resets all changes to the "plugin_id" field.
func (m *EnvPluginMutation) ResetPluginID() {
	m.plugin = nil
}

// SetIsEnable sets the "is_enable" field.
func (m *EnvPluginMutation) SetIsEnable(b bool) {
	m.is_enable = &b
}

// IsEnable returns the value of the "is_enable" field in the mutation.
func (m *EnvPluginMutation) IsEnable() (r bool, exists bool) {
	v := m.is_enable
	if v == nil {
		return
	}
	return *v, true
}

// OldIsEnable returns the old "is_enable" field's value of the EnvPlugin entity.
// If the EnvPlugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvPluginMutation) OldIsEnable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsEnable: %w", err)
	}
	return oldValue.IsEnable, nil
}

// ResetIsEnable resets all changes to the "is_enable" field.
func (m *EnvPluginMutation) ResetIsEnable() {
	m.is_enable = nil
}

// SetExecutionOrder sets the "execution_order" field.
func (m *EnvPluginMutation) SetExecutionOrder(i int32) {
	m.execution_order = &i
	m.addexecution_order = nil
}

// ExecutionOrder returns the value of the "execution_order" field in the mutation.
func (m *EnvPluginMutation) ExecutionOrder() (r int32, exists bool) {
	v := m.execution_order
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutionOrder returns the old "execution_order" field's value of the EnvPlugin entity.
// If the EnvPlugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvPluginMutation) OldExecutionOrder(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutionOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutionOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutionOrder: %w", err)
	}
	return oldValue.ExecutionOrder, nil
}

// AddExecutionOrder adds i to the "execution_order" field.
func (m *EnvPluginMutation) AddExecutionOrder(i int32) {
	if m.addexecution_order != nil {
		*m.addexecution_order += i
	} else {
		m.addexecution_order = &i
	}
}

// AddedExecutionOrder returns the value that was added to the "execution_order" field in this mutation.
func (m *EnvPluginMutation) AddedExecutionOrder() (r int32, exists bool) {
	v := m.addexecution_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetExecutionOrder resets all changes to the "execution_order" field.
func (m *EnvPluginMutation) ResetExecutionOrder() {
	m.execution_order = nil
	m.addexecution_order = nil
}

// SetConfig sets the "config" field.
func (m *EnvPluginMutation) SetConfig(s string) {
	m._config = &s
}

// Config returns the value of the "config" field in the mutation.
func (m *EnvPluginMutation) Config() (r string, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the EnvPlugin entity.
// If the EnvPlugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvPluginMutation) OldConfig(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ClearConfig clears the value of the "config" field.
func (m *EnvPluginMutation) ClearConfig() {
	m._config = nil
	m.clearedFields[envplugin.FieldConfig] = struct{}{}
}

// ConfigCleared returns if the "config" field was cleared in this mutation.
func (m *EnvPluginMutation) ConfigCleared() bool {
	_, ok := m.clearedFields[envplugin.FieldConfig]
	return ok
}

// ResetConfig resets all changes to the "config" field.
func (m *EnvPluginMutation) ResetConfig() {
	m._config = nil
	delete(m.clearedFields, envplugin.FieldConfig)
}

// ClearEnv clears the "env" edge to the Env entity.
func (m *EnvPluginMutation) ClearEnv() {
	m.clearedenv = true
	m.clearedFields[envplugin.FieldEnvID] = struct{}{}
}

// EnvCleared reports if the "env" edge to the Env entity was cleared.
func (m *EnvPluginMutation) EnvCleared() bool {
	return m.clearedenv
}

// EnvIDs returns the "env" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnvID instead. It exists only for internal usage by the builders.
func (m *EnvPluginMutation) EnvIDs() (ids []int64) {
	if id := m.env; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnv resets all changes to the "env" edge.
func (m *EnvPluginMutation) ResetEnv() {
	m.env = nil
	m.clearedenv = false
}

// ClearPlugin clears the "plugin" edge to the Plugin entity.
func (m *EnvPluginMutation) ClearPlugin() {
	m.clearedplugin = true
	m.clearedFields[envplugin.FieldPluginID] = struct{}{}
}

// PluginCleared reports if the "plugin" edge to the Plugin entity was cleared.
func (m *EnvPluginMutation) PluginCleared() bool {
	return m.clearedplugin
}

// PluginIDs returns the "plugin" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PluginID instead. It exists only for internal usage by the builders.
func (m *EnvPluginMutation) PluginIDs() (ids []int64) {
	if id := m.plugin; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlugin resets all changes to the "plugin" edge.
func (m *EnvPluginMutation) ResetPlugin() {
	m.plugin = nil
	m.clearedplugin = false
}

// Where appends a list predicates to the EnvPluginMutation builder.
func (m *EnvPluginMutation) Where(ps ...predicate.EnvPlugin) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EnvPluginMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EnvPluginMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EnvPlugin, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EnvPluginMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EnvPluginMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EnvPlugin).
func (m *EnvPluginMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnvPluginMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, envplugin.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, envplugin.FieldUpdatedAt)
	}
	if m.env != nil {
		fields = append(fields, envplugin.FieldEnvID)
	}
	if m.plugin != nil {
		fields = append(fields, envplugin.FieldPluginID)
	}
	if m.is_enable != nil {
		fields = append(fields, envplugin.FieldIsEnable)
	}
	if m.execution_order != nil {
		fields = append(fields, envplugin.FieldExecutionOrder)
	}
	if m._config != nil {
		fields = append(fields, envplugin.FieldConfig)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnvPluginMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case envplugin.FieldCreatedAt:
		return m.CreatedAt()
	case envplugin.FieldUpdatedAt:
		return m.UpdatedAt()
	case envplugin.FieldEnvID:
		return m.EnvID()
	case envplugin.FieldPluginID:
		return m.PluginID()
	case envplugin.FieldIsEnable:
		return m.IsEnable()
	case envplugin.FieldExecutionOrder:
		return m.ExecutionOrder()
	case envplugin.FieldConfig:
		return m.Config()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnvPluginMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case envplugin.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case envplugin.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case envplugin.FieldEnvID:
		return m.OldEnvID(ctx)
	case envplugin.FieldPluginID:
		return m.OldPluginID(ctx)
	case envplugin.FieldIsEnable:
		return m.OldIsEnable(ctx)
	case envplugin.FieldExecutionOrder:
		return m.OldExecutionOrder(ctx)
	case envplugin.FieldConfig:
		return m.OldConfig(ctx)
	}
	return nil, fmt.Errorf("unknown EnvPlugin field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnvPluginMutation) SetField(name string, value ent.Value) error {
	switch name {
	case envplugin.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case envplugin.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case envplugin.FieldEnvID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnvID(v)
		return nil
	case envplugin.FieldPluginID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPluginID(v)
		return nil
	case envplugin.FieldIsEnable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsEnable(v)
		return nil
	case envplugin.FieldExecutionOrder:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutionOrder(v)
		return nil
	case envplugin.FieldConfig:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	}
	return fmt.Errorf("unknown EnvPlugin field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnvPluginMutation) AddedFields() []string {
	var fields []string
	if m.addexecution_order != nil {
		fields = append(fields, envplugin.FieldExecutionOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnvPluginMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case envplugin.FieldExecutionOrder:
		return m.AddedExecutionOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnvPluginMutation) AddField(name string, value ent.Value) error {
	switch name {
	case envplugin.FieldExecutionOrder:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExecutionOrder(v)
		return nil
	}
	return fmt.Errorf("unknown EnvPlugin numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnvPluginMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(envplugin.FieldConfig) {
		fields = append(fields, envplugin.FieldConfig)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnvPluginMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnvPluginMutation) ClearField(name string) error {
	switch name {
	case envplugin.FieldConfig:
		m.ClearConfig()
		return nil
	}
	return fmt.Errorf("unknown EnvPlugin nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnvPluginMutation) ResetField(name string) error {
	switch name {
	case envplugin.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case envplugin.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case envplugin.FieldEnvID:
		m.ResetEnvID()
		return nil
	case envplugin.FieldPluginID:
		m.ResetPluginID()
		return nil
	case envplugin.FieldIsEnable:
		m.ResetIsEnable()
		return nil
	case envplugin.FieldExecutionOrder:
		m.ResetExecutionOrder()
		return nil
	case envplugin.FieldConfig:
		m.ResetConfig()
		return nil
	}
	return fmt.Errorf("unknown EnvPlugin field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnvPluginMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.env != nil {
		edges = append(edges, envplugin.EdgeEnv)
	}
	if m.plugin != nil {
		edges = append(edges, envplugin.EdgePlugin)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnvPluginMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case envplugin.EdgeEnv:
		if id := m.env; id != nil {
			return []ent.Value{*id}
		}
	case envplugin.EdgePlugin:
		if id := m.plugin; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnvPluginMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnvPluginMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnvPluginMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedenv {
		edges = append(edges, envplugin.EdgeEnv)
	}
	if m.clearedplugin {
		edges = append(edges, envplugin.EdgePlugin)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnvPluginMutation) EdgeCleared(name string) bool {
	switch name {
	case envplugin.EdgeEnv:
		return m.clearedenv
	case envplugin.EdgePlugin:
		return m.clearedplugin
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnvPluginMutation) ClearEdge(name string) error {
	switch name {
	case envplugin.EdgeEnv:
		m.ClearEnv()
		return nil
	case envplugin.EdgePlugin:
		m.ClearPlugin()
		return nil
	}
	return fmt.Errorf("unknown EnvPlugin unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnvPluginMutation) ResetEdge(name string) error {
	switch name {
	case envplugin.EdgeEnv:
		m.ResetEnv()
		return nil
	case envplugin.EdgePlugin:
		m.ResetPlugin()
		return nil
	}
	return fmt.Errorf("unknown EnvPlugin edge %s", name)
}

// LoginHistoryMutation represents an operation that mutates the LoginHistory nodes in the graph.
type LoginHistoryMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	ip            *string
	address       *string
	state         *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*LoginHistory, error)
	predicates    []predicate.LoginHistory
}

var _ ent.Mutation = (*LoginHistoryMutation)(nil)

// loginhistoryOption allows management of the mutation configuration using functional options.
type loginhistoryOption func(*LoginHistoryMutation)

// newLoginHistoryMutation creates new mutation for the LoginHistory entity.
func newLoginHistoryMutation(c config, op Op, opts ...loginhistoryOption) *LoginHistoryMutation {
	m := &LoginHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeLoginHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLoginHistoryID sets the ID field of the mutation.
func withLoginHistoryID(id int64) loginhistoryOption {
	return func(m *LoginHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *LoginHistory
		)
		m.oldValue = func(ctx context.Context) (*LoginHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LoginHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLoginHistory sets the old LoginHistory of the mutation.
func withLoginHistory(node *LoginHistory) loginhistoryOption {
	return func(m *LoginHistoryMutation) {
		m.oldValue = func(context.Context) (*LoginHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LoginHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LoginHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LoginHistory entities.
func (m *LoginHistoryMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LoginHistoryMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LoginHistoryMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LoginHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LoginHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LoginHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LoginHistory entity.
// If the LoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LoginHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LoginHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LoginHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the LoginHistory entity.
// If the LoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LoginHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetIP sets the "ip" field.
func (m *LoginHistoryMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *LoginHistoryMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the LoginHistory entity.
// If the LoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginHistoryMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "ip" field.
func (m *LoginHistoryMutation) ResetIP() {
	m.ip = nil
}

// SetAddress sets the "address" field.
func (m *LoginHistoryMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *LoginHistoryMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the LoginHistory entity.
// If the LoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginHistoryMutation) OldAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *LoginHistoryMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[loginhistory.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *LoginHistoryMutation) AddressCleared() bool {
	_, ok := m.clearedFields[loginhistory.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *LoginHistoryMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, loginhistory.FieldAddress)
}

// SetState sets the "state" field.
func (m *LoginHistoryMutation) SetState(b bool) {
	m.state = &b
}

// State returns the value of the "state" field in the mutation.
func (m *LoginHistoryMutation) State() (r bool, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the LoginHistory entity.
// If the LoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginHistoryMutation) OldState(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *LoginHistoryMutation) ResetState() {
	m.state = nil
}

// Where appends a list predicates to the LoginHistoryMutation builder.
func (m *LoginHistoryMutation) Where(ps ...predicate.LoginHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LoginHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LoginHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LoginHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LoginHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LoginHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LoginHistory).
func (m *LoginHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LoginHistoryMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, loginhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, loginhistory.FieldUpdatedAt)
	}
	if m.ip != nil {
		fields = append(fields, loginhistory.FieldIP)
	}
	if m.address != nil {
		fields = append(fields, loginhistory.FieldAddress)
	}
	if m.state != nil {
		fields = append(fields, loginhistory.FieldState)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LoginHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case loginhistory.FieldCreatedAt:
		return m.CreatedAt()
	case loginhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case loginhistory.FieldIP:
		return m.IP()
	case loginhistory.FieldAddress:
		return m.Address()
	case loginhistory.FieldState:
		return m.State()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LoginHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case loginhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case loginhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case loginhistory.FieldIP:
		return m.OldIP(ctx)
	case loginhistory.FieldAddress:
		return m.OldAddress(ctx)
	case loginhistory.FieldState:
		return m.OldState(ctx)
	}
	return nil, fmt.Errorf("unknown LoginHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LoginHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case loginhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case loginhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case loginhistory.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case loginhistory.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case loginhistory.FieldState:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	}
	return fmt.Errorf("unknown LoginHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LoginHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LoginHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LoginHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LoginHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LoginHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(loginhistory.FieldAddress) {
		fields = append(fields, loginhistory.FieldAddress)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LoginHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LoginHistoryMutation) ClearField(name string) error {
	switch name {
	case loginhistory.FieldAddress:
		m.ClearAddress()
		return nil
	}
	return fmt.Errorf("unknown LoginHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LoginHistoryMutation) ResetField(name string) error {
	switch name {
	case loginhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case loginhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case loginhistory.FieldIP:
		m.ResetIP()
		return nil
	case loginhistory.FieldAddress:
		m.ResetAddress()
		return nil
	case loginhistory.FieldState:
		m.ResetState()
		return nil
	}
	return fmt.Errorf("unknown LoginHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LoginHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LoginHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LoginHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LoginHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LoginHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LoginHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LoginHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown LoginHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LoginHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown LoginHistory edge %s", name)
}

// PanelMutation represents an operation that mutates the Panel nodes in the graph.
type PanelMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	url           *string
	client_id     *string
	client_secret *string
	is_enable     *bool
	token         *string
	params        *int32
	addparams     *int32
	clearedFields map[string]struct{}
	envs          map[int64]struct{}
	removedenvs   map[int64]struct{}
	clearedenvs   bool
	done          bool
	oldValue      func(context.Context) (*Panel, error)
	predicates    []predicate.Panel
}

var _ ent.Mutation = (*PanelMutation)(nil)

// panelOption allows management of the mutation configuration using functional options.
type panelOption func(*PanelMutation)

// newPanelMutation creates new mutation for the Panel entity.
func newPanelMutation(c config, op Op, opts ...panelOption) *PanelMutation {
	m := &PanelMutation{
		config:        c,
		op:            op,
		typ:           TypePanel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPanelID sets the ID field of the mutation.
func withPanelID(id int64) panelOption {
	return func(m *PanelMutation) {
		var (
			err   error
			once  sync.Once
			value *Panel
		)
		m.oldValue = func(ctx context.Context) (*Panel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Panel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPanel sets the old Panel of the mutation.
func withPanel(node *Panel) panelOption {
	return func(m *PanelMutation) {
		m.oldValue = func(context.Context) (*Panel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PanelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PanelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Panel entities.
func (m *PanelMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PanelMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PanelMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Panel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PanelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PanelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Panel entity.
// If the Panel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PanelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PanelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PanelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PanelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Panel entity.
// If the Panel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PanelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PanelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *PanelMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PanelMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Panel entity.
// If the Panel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PanelMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PanelMutation) ResetName() {
	m.name = nil
}

// SetURL sets the "url" field.
func (m *PanelMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *PanelMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Panel entity.
// If the Panel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PanelMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *PanelMutation) ResetURL() {
	m.url = nil
}

// SetClientID sets the "client_id" field.
func (m *PanelMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *PanelMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the Panel entity.
// If the Panel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PanelMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "client_id" field.
func (m *PanelMutation) ResetClientID() {
	m.client_id = nil
}

// SetClientSecret sets the "client_secret" field.
func (m *PanelMutation) SetClientSecret(s string) {
	m.client_secret = &s
}

// ClientSecret returns the value of the "client_secret" field in the mutation.
func (m *PanelMutation) ClientSecret() (r string, exists bool) {
	v := m.client_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldClientSecret returns the old "client_secret" field's value of the Panel entity.
// If the Panel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PanelMutation) OldClientSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientSecret: %w", err)
	}
	return oldValue.ClientSecret, nil
}

// ResetClientSecret resets all changes to the "client_secret" field.
func (m *PanelMutation) ResetClientSecret() {
	m.client_secret = nil
}

// SetIsEnable sets the "is_enable" field.
func (m *PanelMutation) SetIsEnable(b bool) {
	m.is_enable = &b
}

// IsEnable returns the value of the "is_enable" field in the mutation.
func (m *PanelMutation) IsEnable() (r bool, exists bool) {
	v := m.is_enable
	if v == nil {
		return
	}
	return *v, true
}

// OldIsEnable returns the old "is_enable" field's value of the Panel entity.
// If the Panel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PanelMutation) OldIsEnable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsEnable: %w", err)
	}
	return oldValue.IsEnable, nil
}

// ResetIsEnable resets all changes to the "is_enable" field.
func (m *PanelMutation) ResetIsEnable() {
	m.is_enable = nil
}

// SetToken sets the "token" field.
func (m *PanelMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *PanelMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Panel entity.
// If the Panel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PanelMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *PanelMutation) ResetToken() {
	m.token = nil
}

// SetParams sets the "params" field.
func (m *PanelMutation) SetParams(i int32) {
	m.params = &i
	m.addparams = nil
}

// Params returns the value of the "params" field in the mutation.
func (m *PanelMutation) Params() (r int32, exists bool) {
	v := m.params
	if v == nil {
		return
	}
	return *v, true
}

// OldParams returns the old "params" field's value of the Panel entity.
// If the Panel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PanelMutation) OldParams(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParams is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParams requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParams: %w", err)
	}
	return oldValue.Params, nil
}

// AddParams adds i to the "params" field.
func (m *PanelMutation) AddParams(i int32) {
	if m.addparams != nil {
		*m.addparams += i
	} else {
		m.addparams = &i
	}
}

// AddedParams returns the value that was added to the "params" field in this mutation.
func (m *PanelMutation) AddedParams() (r int32, exists bool) {
	v := m.addparams
	if v == nil {
		return
	}
	return *v, true
}

// ResetParams resets all changes to the "params" field.
func (m *PanelMutation) ResetParams() {
	m.params = nil
	m.addparams = nil
}

// AddEnvIDs adds the "envs" edge to the Env entity by ids.
func (m *PanelMutation) AddEnvIDs(ids ...int64) {
	if m.envs == nil {
		m.envs = make(map[int64]struct{})
	}
	for i := range ids {
		m.envs[ids[i]] = struct{}{}
	}
}

// ClearEnvs clears the "envs" edge to the Env entity.
func (m *PanelMutation) ClearEnvs() {
	m.clearedenvs = true
}

// EnvsCleared reports if the "envs" edge to the Env entity was cleared.
func (m *PanelMutation) EnvsCleared() bool {
	return m.clearedenvs
}

// RemoveEnvIDs removes the "envs" edge to the Env entity by IDs.
func (m *PanelMutation) RemoveEnvIDs(ids ...int64) {
	if m.removedenvs == nil {
		m.removedenvs = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.envs, ids[i])
		m.removedenvs[ids[i]] = struct{}{}
	}
}

// RemovedEnvs returns the removed IDs of the "envs" edge to the Env entity.
func (m *PanelMutation) RemovedEnvsIDs() (ids []int64) {
	for id := range m.removedenvs {
		ids = append(ids, id)
	}
	return
}

// EnvsIDs returns the "envs" edge IDs in the mutation.
func (m *PanelMutation) EnvsIDs() (ids []int64) {
	for id := range m.envs {
		ids = append(ids, id)
	}
	return
}

// ResetEnvs resets all changes to the "envs" edge.
func (m *PanelMutation) ResetEnvs() {
	m.envs = nil
	m.clearedenvs = false
	m.removedenvs = nil
}

// Where appends a list predicates to the PanelMutation builder.
func (m *PanelMutation) Where(ps ...predicate.Panel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PanelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PanelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Panel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PanelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PanelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Panel).
func (m *PanelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PanelMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, panel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, panel.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, panel.FieldName)
	}
	if m.url != nil {
		fields = append(fields, panel.FieldURL)
	}
	if m.client_id != nil {
		fields = append(fields, panel.FieldClientID)
	}
	if m.client_secret != nil {
		fields = append(fields, panel.FieldClientSecret)
	}
	if m.is_enable != nil {
		fields = append(fields, panel.FieldIsEnable)
	}
	if m.token != nil {
		fields = append(fields, panel.FieldToken)
	}
	if m.params != nil {
		fields = append(fields, panel.FieldParams)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PanelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case panel.FieldCreatedAt:
		return m.CreatedAt()
	case panel.FieldUpdatedAt:
		return m.UpdatedAt()
	case panel.FieldName:
		return m.Name()
	case panel.FieldURL:
		return m.URL()
	case panel.FieldClientID:
		return m.ClientID()
	case panel.FieldClientSecret:
		return m.ClientSecret()
	case panel.FieldIsEnable:
		return m.IsEnable()
	case panel.FieldToken:
		return m.Token()
	case panel.FieldParams:
		return m.Params()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PanelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case panel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case panel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case panel.FieldName:
		return m.OldName(ctx)
	case panel.FieldURL:
		return m.OldURL(ctx)
	case panel.FieldClientID:
		return m.OldClientID(ctx)
	case panel.FieldClientSecret:
		return m.OldClientSecret(ctx)
	case panel.FieldIsEnable:
		return m.OldIsEnable(ctx)
	case panel.FieldToken:
		return m.OldToken(ctx)
	case panel.FieldParams:
		return m.OldParams(ctx)
	}
	return nil, fmt.Errorf("unknown Panel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PanelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case panel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case panel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case panel.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case panel.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case panel.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case panel.FieldClientSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientSecret(v)
		return nil
	case panel.FieldIsEnable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsEnable(v)
		return nil
	case panel.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case panel.FieldParams:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParams(v)
		return nil
	}
	return fmt.Errorf("unknown Panel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PanelMutation) AddedFields() []string {
	var fields []string
	if m.addparams != nil {
		fields = append(fields, panel.FieldParams)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PanelMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case panel.FieldParams:
		return m.AddedParams()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PanelMutation) AddField(name string, value ent.Value) error {
	switch name {
	case panel.FieldParams:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddParams(v)
		return nil
	}
	return fmt.Errorf("unknown Panel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PanelMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PanelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PanelMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Panel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PanelMutation) ResetField(name string) error {
	switch name {
	case panel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case panel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case panel.FieldName:
		m.ResetName()
		return nil
	case panel.FieldURL:
		m.ResetURL()
		return nil
	case panel.FieldClientID:
		m.ResetClientID()
		return nil
	case panel.FieldClientSecret:
		m.ResetClientSecret()
		return nil
	case panel.FieldIsEnable:
		m.ResetIsEnable()
		return nil
	case panel.FieldToken:
		m.ResetToken()
		return nil
	case panel.FieldParams:
		m.ResetParams()
		return nil
	}
	return fmt.Errorf("unknown Panel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PanelMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.envs != nil {
		edges = append(edges, panel.EdgeEnvs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PanelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case panel.EdgeEnvs:
		ids := make([]ent.Value, 0, len(m.envs))
		for id := range m.envs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PanelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedenvs != nil {
		edges = append(edges, panel.EdgeEnvs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PanelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case panel.EdgeEnvs:
		ids := make([]ent.Value, 0, len(m.removedenvs))
		for id := range m.removedenvs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PanelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedenvs {
		edges = append(edges, panel.EdgeEnvs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PanelMutation) EdgeCleared(name string) bool {
	switch name {
	case panel.EdgeEnvs:
		return m.clearedenvs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PanelMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Panel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PanelMutation) ResetEdge(name string) error {
	switch name {
	case panel.EdgeEnvs:
		m.ResetEnvs()
		return nil
	}
	return fmt.Errorf("unknown Panel edge %s", name)
}

// PluginMutation represents an operation that mutates the Plugin nodes in the graph.
type PluginMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	created_at            *time.Time
	updated_at            *time.Time
	name                  *string
	description           *string
	version               *string
	author                *string
	script_content        *string
	is_enable             *bool
	execution_timeout     *int32
	addexecution_timeout  *int32
	trigger_event         *string
	priority              *int32
	addpriority           *int32
	clearedFields         map[string]struct{}
	env_plugins           map[int64]struct{}
	removedenv_plugins    map[int64]struct{}
	clearedenv_plugins    bool
	execution_logs        map[int64]struct{}
	removedexecution_logs map[int64]struct{}
	clearedexecution_logs bool
	done                  bool
	oldValue              func(context.Context) (*Plugin, error)
	predicates            []predicate.Plugin
}

var _ ent.Mutation = (*PluginMutation)(nil)

// pluginOption allows management of the mutation configuration using functional options.
type pluginOption func(*PluginMutation)

// newPluginMutation creates new mutation for the Plugin entity.
func newPluginMutation(c config, op Op, opts ...pluginOption) *PluginMutation {
	m := &PluginMutation{
		config:        c,
		op:            op,
		typ:           TypePlugin,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPluginID sets the ID field of the mutation.
func withPluginID(id int64) pluginOption {
	return func(m *PluginMutation) {
		var (
			err   error
			once  sync.Once
			value *Plugin
		)
		m.oldValue = func(ctx context.Context) (*Plugin, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Plugin.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlugin sets the old Plugin of the mutation.
func withPlugin(node *Plugin) pluginOption {
	return func(m *PluginMutation) {
		m.oldValue = func(context.Context) (*Plugin, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PluginMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PluginMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Plugin entities.
func (m *PluginMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PluginMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PluginMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Plugin.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PluginMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PluginMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Plugin entity.
// If the Plugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PluginMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PluginMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PluginMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Plugin entity.
// If the Plugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PluginMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *PluginMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PluginMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Plugin entity.
// If the Plugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PluginMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *PluginMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PluginMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Plugin entity.
// If the Plugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PluginMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[plugin.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PluginMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[plugin.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PluginMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, plugin.FieldDescription)
}

// SetVersion sets the "version" field.
func (m *PluginMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *PluginMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Plugin entity.
// If the Plugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *PluginMutation) ResetVersion() {
	m.version = nil
}

// SetAuthor sets the "author" field.
func (m *PluginMutation) SetAuthor(s string) {
	m.author = &s
}

// Author returns the value of the "author" field in the mutation.
func (m *PluginMutation) Author() (r string, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthor returns the old "author" field's value of the Plugin entity.
// If the Plugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginMutation) OldAuthor(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthor: %w", err)
	}
	return oldValue.Author, nil
}

// ClearAuthor clears the value of the "author" field.
func (m *PluginMutation) ClearAuthor() {
	m.author = nil
	m.clearedFields[plugin.FieldAuthor] = struct{}{}
}

// AuthorCleared returns if the "author" field was cleared in this mutation.
func (m *PluginMutation) AuthorCleared() bool {
	_, ok := m.clearedFields[plugin.FieldAuthor]
	return ok
}

// ResetAuthor resets all changes to the "author" field.
func (m *PluginMutation) ResetAuthor() {
	m.author = nil
	delete(m.clearedFields, plugin.FieldAuthor)
}

// SetScriptContent sets the "script_content" field.
func (m *PluginMutation) SetScriptContent(s string) {
	m.script_content = &s
}

// ScriptContent returns the value of the "script_content" field in the mutation.
func (m *PluginMutation) ScriptContent() (r string, exists bool) {
	v := m.script_content
	if v == nil {
		return
	}
	return *v, true
}

// OldScriptContent returns the old "script_content" field's value of the Plugin entity.
// If the Plugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginMutation) OldScriptContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScriptContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScriptContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScriptContent: %w", err)
	}
	return oldValue.ScriptContent, nil
}

// ResetScriptContent resets all changes to the "script_content" field.
func (m *PluginMutation) ResetScriptContent() {
	m.script_content = nil
}

// SetIsEnable sets the "is_enable" field.
func (m *PluginMutation) SetIsEnable(b bool) {
	m.is_enable = &b
}

// IsEnable returns the value of the "is_enable" field in the mutation.
func (m *PluginMutation) IsEnable() (r bool, exists bool) {
	v := m.is_enable
	if v == nil {
		return
	}
	return *v, true
}

// OldIsEnable returns the old "is_enable" field's value of the Plugin entity.
// If the Plugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginMutation) OldIsEnable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsEnable: %w", err)
	}
	return oldValue.IsEnable, nil
}

// ResetIsEnable resets all changes to the "is_enable" field.
func (m *PluginMutation) ResetIsEnable() {
	m.is_enable = nil
}

// SetExecutionTimeout sets the "execution_timeout" field.
func (m *PluginMutation) SetExecutionTimeout(i int32) {
	m.execution_timeout = &i
	m.addexecution_timeout = nil
}

// ExecutionTimeout returns the value of the "execution_timeout" field in the mutation.
func (m *PluginMutation) ExecutionTimeout() (r int32, exists bool) {
	v := m.execution_timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutionTimeout returns the old "execution_timeout" field's value of the Plugin entity.
// If the Plugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginMutation) OldExecutionTimeout(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutionTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutionTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutionTimeout: %w", err)
	}
	return oldValue.ExecutionTimeout, nil
}

// AddExecutionTimeout adds i to the "execution_timeout" field.
func (m *PluginMutation) AddExecutionTimeout(i int32) {
	if m.addexecution_timeout != nil {
		*m.addexecution_timeout += i
	} else {
		m.addexecution_timeout = &i
	}
}

// AddedExecutionTimeout returns the value that was added to the "execution_timeout" field in this mutation.
func (m *PluginMutation) AddedExecutionTimeout() (r int32, exists bool) {
	v := m.addexecution_timeout
	if v == nil {
		return
	}
	return *v, true
}

// ResetExecutionTimeout resets all changes to the "execution_timeout" field.
func (m *PluginMutation) ResetExecutionTimeout() {
	m.execution_timeout = nil
	m.addexecution_timeout = nil
}

// SetTriggerEvent sets the "trigger_event" field.
func (m *PluginMutation) SetTriggerEvent(s string) {
	m.trigger_event = &s
}

// TriggerEvent returns the value of the "trigger_event" field in the mutation.
func (m *PluginMutation) TriggerEvent() (r string, exists bool) {
	v := m.trigger_event
	if v == nil {
		return
	}
	return *v, true
}

// OldTriggerEvent returns the old "trigger_event" field's value of the Plugin entity.
// If the Plugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginMutation) OldTriggerEvent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTriggerEvent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTriggerEvent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTriggerEvent: %w", err)
	}
	return oldValue.TriggerEvent, nil
}

// ResetTriggerEvent resets all changes to the "trigger_event" field.
func (m *PluginMutation) ResetTriggerEvent() {
	m.trigger_event = nil
}

// SetPriority sets the "priority" field.
func (m *PluginMutation) SetPriority(i int32) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *PluginMutation) Priority() (r int32, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Plugin entity.
// If the Plugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginMutation) OldPriority(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *PluginMutation) AddPriority(i int32) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *PluginMutation) AddedPriority() (r int32, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *PluginMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// AddEnvPluginIDs adds the "env_plugins" edge to the EnvPlugin entity by ids.
func (m *PluginMutation) AddEnvPluginIDs(ids ...int64) {
	if m.env_plugins == nil {
		m.env_plugins = make(map[int64]struct{})
	}
	for i := range ids {
		m.env_plugins[ids[i]] = struct{}{}
	}
}

// ClearEnvPlugins clears the "env_plugins" edge to the EnvPlugin entity.
func (m *PluginMutation) ClearEnvPlugins() {
	m.clearedenv_plugins = true
}

// EnvPluginsCleared reports if the "env_plugins" edge to the EnvPlugin entity was cleared.
func (m *PluginMutation) EnvPluginsCleared() bool {
	return m.clearedenv_plugins
}

// RemoveEnvPluginIDs removes the "env_plugins" edge to the EnvPlugin entity by IDs.
func (m *PluginMutation) RemoveEnvPluginIDs(ids ...int64) {
	if m.removedenv_plugins == nil {
		m.removedenv_plugins = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.env_plugins, ids[i])
		m.removedenv_plugins[ids[i]] = struct{}{}
	}
}

// RemovedEnvPlugins returns the removed IDs of the "env_plugins" edge to the EnvPlugin entity.
func (m *PluginMutation) RemovedEnvPluginsIDs() (ids []int64) {
	for id := range m.removedenv_plugins {
		ids = append(ids, id)
	}
	return
}

// EnvPluginsIDs returns the "env_plugins" edge IDs in the mutation.
func (m *PluginMutation) EnvPluginsIDs() (ids []int64) {
	for id := range m.env_plugins {
		ids = append(ids, id)
	}
	return
}

// ResetEnvPlugins resets all changes to the "env_plugins" edge.
func (m *PluginMutation) ResetEnvPlugins() {
	m.env_plugins = nil
	m.clearedenv_plugins = false
	m.removedenv_plugins = nil
}

// AddExecutionLogIDs adds the "execution_logs" edge to the PluginExecutionLog entity by ids.
func (m *PluginMutation) AddExecutionLogIDs(ids ...int64) {
	if m.execution_logs == nil {
		m.execution_logs = make(map[int64]struct{})
	}
	for i := range ids {
		m.execution_logs[ids[i]] = struct{}{}
	}
}

// ClearExecutionLogs clears the "execution_logs" edge to the PluginExecutionLog entity.
func (m *PluginMutation) ClearExecutionLogs() {
	m.clearedexecution_logs = true
}

// ExecutionLogsCleared reports if the "execution_logs" edge to the PluginExecutionLog entity was cleared.
func (m *PluginMutation) ExecutionLogsCleared() bool {
	return m.clearedexecution_logs
}

// RemoveExecutionLogIDs removes the "execution_logs" edge to the PluginExecutionLog entity by IDs.
func (m *PluginMutation) RemoveExecutionLogIDs(ids ...int64) {
	if m.removedexecution_logs == nil {
		m.removedexecution_logs = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.execution_logs, ids[i])
		m.removedexecution_logs[ids[i]] = struct{}{}
	}
}

// RemovedExecutionLogs returns the removed IDs of the "execution_logs" edge to the PluginExecutionLog entity.
func (m *PluginMutation) RemovedExecutionLogsIDs() (ids []int64) {
	for id := range m.removedexecution_logs {
		ids = append(ids, id)
	}
	return
}

// ExecutionLogsIDs returns the "execution_logs" edge IDs in the mutation.
func (m *PluginMutation) ExecutionLogsIDs() (ids []int64) {
	for id := range m.execution_logs {
		ids = append(ids, id)
	}
	return
}

// ResetExecutionLogs resets all changes to the "execution_logs" edge.
func (m *PluginMutation) ResetExecutionLogs() {
	m.execution_logs = nil
	m.clearedexecution_logs = false
	m.removedexecution_logs = nil
}

// Where appends a list predicates to the PluginMutation builder.
func (m *PluginMutation) Where(ps ...predicate.Plugin) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PluginMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PluginMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Plugin, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PluginMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PluginMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Plugin).
func (m *PluginMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PluginMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, plugin.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, plugin.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, plugin.FieldName)
	}
	if m.description != nil {
		fields = append(fields, plugin.FieldDescription)
	}
	if m.version != nil {
		fields = append(fields, plugin.FieldVersion)
	}
	if m.author != nil {
		fields = append(fields, plugin.FieldAuthor)
	}
	if m.script_content != nil {
		fields = append(fields, plugin.FieldScriptContent)
	}
	if m.is_enable != nil {
		fields = append(fields, plugin.FieldIsEnable)
	}
	if m.execution_timeout != nil {
		fields = append(fields, plugin.FieldExecutionTimeout)
	}
	if m.trigger_event != nil {
		fields = append(fields, plugin.FieldTriggerEvent)
	}
	if m.priority != nil {
		fields = append(fields, plugin.FieldPriority)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PluginMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case plugin.FieldCreatedAt:
		return m.CreatedAt()
	case plugin.FieldUpdatedAt:
		return m.UpdatedAt()
	case plugin.FieldName:
		return m.Name()
	case plugin.FieldDescription:
		return m.Description()
	case plugin.FieldVersion:
		return m.Version()
	case plugin.FieldAuthor:
		return m.Author()
	case plugin.FieldScriptContent:
		return m.ScriptContent()
	case plugin.FieldIsEnable:
		return m.IsEnable()
	case plugin.FieldExecutionTimeout:
		return m.ExecutionTimeout()
	case plugin.FieldTriggerEvent:
		return m.TriggerEvent()
	case plugin.FieldPriority:
		return m.Priority()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PluginMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case plugin.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case plugin.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case plugin.FieldName:
		return m.OldName(ctx)
	case plugin.FieldDescription:
		return m.OldDescription(ctx)
	case plugin.FieldVersion:
		return m.OldVersion(ctx)
	case plugin.FieldAuthor:
		return m.OldAuthor(ctx)
	case plugin.FieldScriptContent:
		return m.OldScriptContent(ctx)
	case plugin.FieldIsEnable:
		return m.OldIsEnable(ctx)
	case plugin.FieldExecutionTimeout:
		return m.OldExecutionTimeout(ctx)
	case plugin.FieldTriggerEvent:
		return m.OldTriggerEvent(ctx)
	case plugin.FieldPriority:
		return m.OldPriority(ctx)
	}
	return nil, fmt.Errorf("unknown Plugin field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PluginMutation) SetField(name string, value ent.Value) error {
	switch name {
	case plugin.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case plugin.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case plugin.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case plugin.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case plugin.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case plugin.FieldAuthor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthor(v)
		return nil
	case plugin.FieldScriptContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScriptContent(v)
		return nil
	case plugin.FieldIsEnable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsEnable(v)
		return nil
	case plugin.FieldExecutionTimeout:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutionTimeout(v)
		return nil
	case plugin.FieldTriggerEvent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTriggerEvent(v)
		return nil
	case plugin.FieldPriority:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	}
	return fmt.Errorf("unknown Plugin field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PluginMutation) AddedFields() []string {
	var fields []string
	if m.addexecution_timeout != nil {
		fields = append(fields, plugin.FieldExecutionTimeout)
	}
	if m.addpriority != nil {
		fields = append(fields, plugin.FieldPriority)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PluginMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case plugin.FieldExecutionTimeout:
		return m.AddedExecutionTimeout()
	case plugin.FieldPriority:
		return m.AddedPriority()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PluginMutation) AddField(name string, value ent.Value) error {
	switch name {
	case plugin.FieldExecutionTimeout:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExecutionTimeout(v)
		return nil
	case plugin.FieldPriority:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	}
	return fmt.Errorf("unknown Plugin numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PluginMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(plugin.FieldDescription) {
		fields = append(fields, plugin.FieldDescription)
	}
	if m.FieldCleared(plugin.FieldAuthor) {
		fields = append(fields, plugin.FieldAuthor)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PluginMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PluginMutation) ClearField(name string) error {
	switch name {
	case plugin.FieldDescription:
		m.ClearDescription()
		return nil
	case plugin.FieldAuthor:
		m.ClearAuthor()
		return nil
	}
	return fmt.Errorf("unknown Plugin nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PluginMutation) ResetField(name string) error {
	switch name {
	case plugin.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case plugin.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case plugin.FieldName:
		m.ResetName()
		return nil
	case plugin.FieldDescription:
		m.ResetDescription()
		return nil
	case plugin.FieldVersion:
		m.ResetVersion()
		return nil
	case plugin.FieldAuthor:
		m.ResetAuthor()
		return nil
	case plugin.FieldScriptContent:
		m.ResetScriptContent()
		return nil
	case plugin.FieldIsEnable:
		m.ResetIsEnable()
		return nil
	case plugin.FieldExecutionTimeout:
		m.ResetExecutionTimeout()
		return nil
	case plugin.FieldTriggerEvent:
		m.ResetTriggerEvent()
		return nil
	case plugin.FieldPriority:
		m.ResetPriority()
		return nil
	}
	return fmt.Errorf("unknown Plugin field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PluginMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.env_plugins != nil {
		edges = append(edges, plugin.EdgeEnvPlugins)
	}
	if m.execution_logs != nil {
		edges = append(edges, plugin.EdgeExecutionLogs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PluginMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case plugin.EdgeEnvPlugins:
		ids := make([]ent.Value, 0, len(m.env_plugins))
		for id := range m.env_plugins {
			ids = append(ids, id)
		}
		return ids
	case plugin.EdgeExecutionLogs:
		ids := make([]ent.Value, 0, len(m.execution_logs))
		for id := range m.execution_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PluginMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedenv_plugins != nil {
		edges = append(edges, plugin.EdgeEnvPlugins)
	}
	if m.removedexecution_logs != nil {
		edges = append(edges, plugin.EdgeExecutionLogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PluginMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case plugin.EdgeEnvPlugins:
		ids := make([]ent.Value, 0, len(m.removedenv_plugins))
		for id := range m.removedenv_plugins {
			ids = append(ids, id)
		}
		return ids
	case plugin.EdgeExecutionLogs:
		ids := make([]ent.Value, 0, len(m.removedexecution_logs))
		for id := range m.removedexecution_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PluginMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedenv_plugins {
		edges = append(edges, plugin.EdgeEnvPlugins)
	}
	if m.clearedexecution_logs {
		edges = append(edges, plugin.EdgeExecutionLogs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PluginMutation) EdgeCleared(name string) bool {
	switch name {
	case plugin.EdgeEnvPlugins:
		return m.clearedenv_plugins
	case plugin.EdgeExecutionLogs:
		return m.clearedexecution_logs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PluginMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Plugin unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PluginMutation) ResetEdge(name string) error {
	switch name {
	case plugin.EdgeEnvPlugins:
		m.ResetEnvPlugins()
		return nil
	case plugin.EdgeExecutionLogs:
		m.ResetExecutionLogs()
		return nil
	}
	return fmt.Errorf("unknown Plugin edge %s", name)
}

// PluginExecutionLogMutation represents an operation that mutates the PluginExecutionLog nodes in the graph.
type PluginExecutionLogMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	created_at        *time.Time
	env_id            *int64
	addenv_id         *int64
	execution_status  *string
	execution_time    *int32
	addexecution_time *int32
	input_data        *string
	output_data       *string
	error_message     *string
	stack_trace       *string
	clearedFields     map[string]struct{}
	plugin            *int64
	clearedplugin     bool
	done              bool
	oldValue          func(context.Context) (*PluginExecutionLog, error)
	predicates        []predicate.PluginExecutionLog
}

var _ ent.Mutation = (*PluginExecutionLogMutation)(nil)

// pluginexecutionlogOption allows management of the mutation configuration using functional options.
type pluginexecutionlogOption func(*PluginExecutionLogMutation)

// newPluginExecutionLogMutation creates new mutation for the PluginExecutionLog entity.
func newPluginExecutionLogMutation(c config, op Op, opts ...pluginexecutionlogOption) *PluginExecutionLogMutation {
	m := &PluginExecutionLogMutation{
		config:        c,
		op:            op,
		typ:           TypePluginExecutionLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPluginExecutionLogID sets the ID field of the mutation.
func withPluginExecutionLogID(id int64) pluginexecutionlogOption {
	return func(m *PluginExecutionLogMutation) {
		var (
			err   error
			once  sync.Once
			value *PluginExecutionLog
		)
		m.oldValue = func(ctx context.Context) (*PluginExecutionLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PluginExecutionLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPluginExecutionLog sets the old PluginExecutionLog of the mutation.
func withPluginExecutionLog(node *PluginExecutionLog) pluginexecutionlogOption {
	return func(m *PluginExecutionLogMutation) {
		m.oldValue = func(context.Context) (*PluginExecutionLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PluginExecutionLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PluginExecutionLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PluginExecutionLog entities.
func (m *PluginExecutionLogMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PluginExecutionLogMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PluginExecutionLogMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PluginExecutionLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PluginExecutionLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PluginExecutionLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PluginExecutionLog entity.
// If the PluginExecutionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginExecutionLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PluginExecutionLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetPluginID sets the "plugin_id" field.
func (m *PluginExecutionLogMutation) SetPluginID(i int64) {
	m.plugin = &i
}

// PluginID returns the value of the "plugin_id" field in the mutation.
func (m *PluginExecutionLogMutation) PluginID() (r int64, exists bool) {
	v := m.plugin
	if v == nil {
		return
	}
	return *v, true
}

// OldPluginID returns the old "plugin_id" field's value of the PluginExecutionLog entity.
// If the PluginExecutionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginExecutionLogMutation) OldPluginID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPluginID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPluginID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPluginID: %w", err)
	}
	return oldValue.PluginID, nil
}

// ResetPluginID resets all changes to the "plugin_id" field.
func (m *PluginExecutionLogMutation) ResetPluginID() {
	m.plugin = nil
}

// SetEnvID sets the "env_id" field.
func (m *PluginExecutionLogMutation) SetEnvID(i int64) {
	m.env_id = &i
	m.addenv_id = nil
}

// EnvID returns the value of the "env_id" field in the mutation.
func (m *PluginExecutionLogMutation) EnvID() (r int64, exists bool) {
	v := m.env_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEnvID returns the old "env_id" field's value of the PluginExecutionLog entity.
// If the PluginExecutionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginExecutionLogMutation) OldEnvID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnvID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnvID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnvID: %w", err)
	}
	return oldValue.EnvID, nil
}

// AddEnvID adds i to the "env_id" field.
func (m *PluginExecutionLogMutation) AddEnvID(i int64) {
	if m.addenv_id != nil {
		*m.addenv_id += i
	} else {
		m.addenv_id = &i
	}
}

// AddedEnvID returns the value that was added to the "env_id" field in this mutation.
func (m *PluginExecutionLogMutation) AddedEnvID() (r int64, exists bool) {
	v := m.addenv_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnvID resets all changes to the "env_id" field.
func (m *PluginExecutionLogMutation) ResetEnvID() {
	m.env_id = nil
	m.addenv_id = nil
}

// SetExecutionStatus sets the "execution_status" field.
func (m *PluginExecutionLogMutation) SetExecutionStatus(s string) {
	m.execution_status = &s
}

// ExecutionStatus returns the value of the "execution_status" field in the mutation.
func (m *PluginExecutionLogMutation) ExecutionStatus() (r string, exists bool) {
	v := m.execution_status
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutionStatus returns the old "execution_status" field's value of the PluginExecutionLog entity.
// If the PluginExecutionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginExecutionLogMutation) OldExecutionStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutionStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutionStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutionStatus: %w", err)
	}
	return oldValue.ExecutionStatus, nil
}

// ResetExecutionStatus resets all changes to the "execution_status" field.
func (m *PluginExecutionLogMutation) ResetExecutionStatus() {
	m.execution_status = nil
}

// SetExecutionTime sets the "execution_time" field.
func (m *PluginExecutionLogMutation) SetExecutionTime(i int32) {
	m.execution_time = &i
	m.addexecution_time = nil
}

// ExecutionTime returns the value of the "execution_time" field in the mutation.
func (m *PluginExecutionLogMutation) ExecutionTime() (r int32, exists bool) {
	v := m.execution_time
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutionTime returns the old "execution_time" field's value of the PluginExecutionLog entity.
// If the PluginExecutionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginExecutionLogMutation) OldExecutionTime(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutionTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutionTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutionTime: %w", err)
	}
	return oldValue.ExecutionTime, nil
}

// AddExecutionTime adds i to the "execution_time" field.
func (m *PluginExecutionLogMutation) AddExecutionTime(i int32) {
	if m.addexecution_time != nil {
		*m.addexecution_time += i
	} else {
		m.addexecution_time = &i
	}
}

// AddedExecutionTime returns the value that was added to the "execution_time" field in this mutation.
func (m *PluginExecutionLogMutation) AddedExecutionTime() (r int32, exists bool) {
	v := m.addexecution_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetExecutionTime resets all changes to the "execution_time" field.
func (m *PluginExecutionLogMutation) ResetExecutionTime() {
	m.execution_time = nil
	m.addexecution_time = nil
}

// SetInputData sets the "input_data" field.
func (m *PluginExecutionLogMutation) SetInputData(s string) {
	m.input_data = &s
}

// InputData returns the value of the "input_data" field in the mutation.
func (m *PluginExecutionLogMutation) InputData() (r string, exists bool) {
	v := m.input_data
	if v == nil {
		return
	}
	return *v, true
}

// OldInputData returns the old "input_data" field's value of the PluginExecutionLog entity.
// If the PluginExecutionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginExecutionLogMutation) OldInputData(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInputData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInputData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInputData: %w", err)
	}
	return oldValue.InputData, nil
}

// ClearInputData clears the value of the "input_data" field.
func (m *PluginExecutionLogMutation) ClearInputData() {
	m.input_data = nil
	m.clearedFields[pluginexecutionlog.FieldInputData] = struct{}{}
}

// InputDataCleared returns if the "input_data" field was cleared in this mutation.
func (m *PluginExecutionLogMutation) InputDataCleared() bool {
	_, ok := m.clearedFields[pluginexecutionlog.FieldInputData]
	return ok
}

// ResetInputData resets all changes to the "input_data" field.
func (m *PluginExecutionLogMutation) ResetInputData() {
	m.input_data = nil
	delete(m.clearedFields, pluginexecutionlog.FieldInputData)
}

// SetOutputData sets the "output_data" field.
func (m *PluginExecutionLogMutation) SetOutputData(s string) {
	m.output_data = &s
}

// OutputData returns the value of the "output_data" field in the mutation.
func (m *PluginExecutionLogMutation) OutputData() (r string, exists bool) {
	v := m.output_data
	if v == nil {
		return
	}
	return *v, true
}

// OldOutputData returns the old "output_data" field's value of the PluginExecutionLog entity.
// If the PluginExecutionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginExecutionLogMutation) OldOutputData(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutputData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutputData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutputData: %w", err)
	}
	return oldValue.OutputData, nil
}

// ClearOutputData clears the value of the "output_data" field.
func (m *PluginExecutionLogMutation) ClearOutputData() {
	m.output_data = nil
	m.clearedFields[pluginexecutionlog.FieldOutputData] = struct{}{}
}

// OutputDataCleared returns if the "output_data" field was cleared in this mutation.
func (m *PluginExecutionLogMutation) OutputDataCleared() bool {
	_, ok := m.clearedFields[pluginexecutionlog.FieldOutputData]
	return ok
}

// ResetOutputData resets all changes to the "output_data" field.
func (m *PluginExecutionLogMutation) ResetOutputData() {
	m.output_data = nil
	delete(m.clearedFields, pluginexecutionlog.FieldOutputData)
}

// SetErrorMessage sets the "error_message" field.
func (m *PluginExecutionLogMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *PluginExecutionLogMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the PluginExecutionLog entity.
// If the PluginExecutionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginExecutionLogMutation) OldErrorMessage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *PluginExecutionLogMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[pluginexecutionlog.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *PluginExecutionLogMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[pluginexecutionlog.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *PluginExecutionLogMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, pluginexecutionlog.FieldErrorMessage)
}

// SetStackTrace sets the "stack_trace" field.
func (m *PluginExecutionLogMutation) SetStackTrace(s string) {
	m.stack_trace = &s
}

// StackTrace returns the value of the "stack_trace" field in the mutation.
func (m *PluginExecutionLogMutation) StackTrace() (r string, exists bool) {
	v := m.stack_trace
	if v == nil {
		return
	}
	return *v, true
}

// OldStackTrace returns the old "stack_trace" field's value of the PluginExecutionLog entity.
// If the PluginExecutionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginExecutionLogMutation) OldStackTrace(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStackTrace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStackTrace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStackTrace: %w", err)
	}
	return oldValue.StackTrace, nil
}

// ClearStackTrace clears the value of the "stack_trace" field.
func (m *PluginExecutionLogMutation) ClearStackTrace() {
	m.stack_trace = nil
	m.clearedFields[pluginexecutionlog.FieldStackTrace] = struct{}{}
}

// StackTraceCleared returns if the "stack_trace" field was cleared in this mutation.
func (m *PluginExecutionLogMutation) StackTraceCleared() bool {
	_, ok := m.clearedFields[pluginexecutionlog.FieldStackTrace]
	return ok
}

// ResetStackTrace resets all changes to the "stack_trace" field.
func (m *PluginExecutionLogMutation) ResetStackTrace() {
	m.stack_trace = nil
	delete(m.clearedFields, pluginexecutionlog.FieldStackTrace)
}

// ClearPlugin clears the "plugin" edge to the Plugin entity.
func (m *PluginExecutionLogMutation) ClearPlugin() {
	m.clearedplugin = true
	m.clearedFields[pluginexecutionlog.FieldPluginID] = struct{}{}
}

// PluginCleared reports if the "plugin" edge to the Plugin entity was cleared.
func (m *PluginExecutionLogMutation) PluginCleared() bool {
	return m.clearedplugin
}

// PluginIDs returns the "plugin" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PluginID instead. It exists only for internal usage by the builders.
func (m *PluginExecutionLogMutation) PluginIDs() (ids []int64) {
	if id := m.plugin; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlugin resets all changes to the "plugin" edge.
func (m *PluginExecutionLogMutation) ResetPlugin() {
	m.plugin = nil
	m.clearedplugin = false
}

// Where appends a list predicates to the PluginExecutionLogMutation builder.
func (m *PluginExecutionLogMutation) Where(ps ...predicate.PluginExecutionLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PluginExecutionLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PluginExecutionLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PluginExecutionLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PluginExecutionLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PluginExecutionLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PluginExecutionLog).
func (m *PluginExecutionLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PluginExecutionLogMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, pluginexecutionlog.FieldCreatedAt)
	}
	if m.plugin != nil {
		fields = append(fields, pluginexecutionlog.FieldPluginID)
	}
	if m.env_id != nil {
		fields = append(fields, pluginexecutionlog.FieldEnvID)
	}
	if m.execution_status != nil {
		fields = append(fields, pluginexecutionlog.FieldExecutionStatus)
	}
	if m.execution_time != nil {
		fields = append(fields, pluginexecutionlog.FieldExecutionTime)
	}
	if m.input_data != nil {
		fields = append(fields, pluginexecutionlog.FieldInputData)
	}
	if m.output_data != nil {
		fields = append(fields, pluginexecutionlog.FieldOutputData)
	}
	if m.error_message != nil {
		fields = append(fields, pluginexecutionlog.FieldErrorMessage)
	}
	if m.stack_trace != nil {
		fields = append(fields, pluginexecutionlog.FieldStackTrace)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PluginExecutionLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pluginexecutionlog.FieldCreatedAt:
		return m.CreatedAt()
	case pluginexecutionlog.FieldPluginID:
		return m.PluginID()
	case pluginexecutionlog.FieldEnvID:
		return m.EnvID()
	case pluginexecutionlog.FieldExecutionStatus:
		return m.ExecutionStatus()
	case pluginexecutionlog.FieldExecutionTime:
		return m.ExecutionTime()
	case pluginexecutionlog.FieldInputData:
		return m.InputData()
	case pluginexecutionlog.FieldOutputData:
		return m.OutputData()
	case pluginexecutionlog.FieldErrorMessage:
		return m.ErrorMessage()
	case pluginexecutionlog.FieldStackTrace:
		return m.StackTrace()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PluginExecutionLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pluginexecutionlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case pluginexecutionlog.FieldPluginID:
		return m.OldPluginID(ctx)
	case pluginexecutionlog.FieldEnvID:
		return m.OldEnvID(ctx)
	case pluginexecutionlog.FieldExecutionStatus:
		return m.OldExecutionStatus(ctx)
	case pluginexecutionlog.FieldExecutionTime:
		return m.OldExecutionTime(ctx)
	case pluginexecutionlog.FieldInputData:
		return m.OldInputData(ctx)
	case pluginexecutionlog.FieldOutputData:
		return m.OldOutputData(ctx)
	case pluginexecutionlog.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case pluginexecutionlog.FieldStackTrace:
		return m.OldStackTrace(ctx)
	}
	return nil, fmt.Errorf("unknown PluginExecutionLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PluginExecutionLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pluginexecutionlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case pluginexecutionlog.FieldPluginID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPluginID(v)
		return nil
	case pluginexecutionlog.FieldEnvID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnvID(v)
		return nil
	case pluginexecutionlog.FieldExecutionStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutionStatus(v)
		return nil
	case pluginexecutionlog.FieldExecutionTime:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutionTime(v)
		return nil
	case pluginexecutionlog.FieldInputData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInputData(v)
		return nil
	case pluginexecutionlog.FieldOutputData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutputData(v)
		return nil
	case pluginexecutionlog.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case pluginexecutionlog.FieldStackTrace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStackTrace(v)
		return nil
	}
	return fmt.Errorf("unknown PluginExecutionLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PluginExecutionLogMutation) AddedFields() []string {
	var fields []string
	if m.addenv_id != nil {
		fields = append(fields, pluginexecutionlog.FieldEnvID)
	}
	if m.addexecution_time != nil {
		fields = append(fields, pluginexecutionlog.FieldExecutionTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PluginExecutionLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case pluginexecutionlog.FieldEnvID:
		return m.AddedEnvID()
	case pluginexecutionlog.FieldExecutionTime:
		return m.AddedExecutionTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PluginExecutionLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case pluginexecutionlog.FieldEnvID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnvID(v)
		return nil
	case pluginexecutionlog.FieldExecutionTime:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExecutionTime(v)
		return nil
	}
	return fmt.Errorf("unknown PluginExecutionLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PluginExecutionLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pluginexecutionlog.FieldInputData) {
		fields = append(fields, pluginexecutionlog.FieldInputData)
	}
	if m.FieldCleared(pluginexecutionlog.FieldOutputData) {
		fields = append(fields, pluginexecutionlog.FieldOutputData)
	}
	if m.FieldCleared(pluginexecutionlog.FieldErrorMessage) {
		fields = append(fields, pluginexecutionlog.FieldErrorMessage)
	}
	if m.FieldCleared(pluginexecutionlog.FieldStackTrace) {
		fields = append(fields, pluginexecutionlog.FieldStackTrace)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PluginExecutionLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PluginExecutionLogMutation) ClearField(name string) error {
	switch name {
	case pluginexecutionlog.FieldInputData:
		m.ClearInputData()
		return nil
	case pluginexecutionlog.FieldOutputData:
		m.ClearOutputData()
		return nil
	case pluginexecutionlog.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case pluginexecutionlog.FieldStackTrace:
		m.ClearStackTrace()
		return nil
	}
	return fmt.Errorf("unknown PluginExecutionLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PluginExecutionLogMutation) ResetField(name string) error {
	switch name {
	case pluginexecutionlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case pluginexecutionlog.FieldPluginID:
		m.ResetPluginID()
		return nil
	case pluginexecutionlog.FieldEnvID:
		m.ResetEnvID()
		return nil
	case pluginexecutionlog.FieldExecutionStatus:
		m.ResetExecutionStatus()
		return nil
	case pluginexecutionlog.FieldExecutionTime:
		m.ResetExecutionTime()
		return nil
	case pluginexecutionlog.FieldInputData:
		m.ResetInputData()
		return nil
	case pluginexecutionlog.FieldOutputData:
		m.ResetOutputData()
		return nil
	case pluginexecutionlog.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case pluginexecutionlog.FieldStackTrace:
		m.ResetStackTrace()
		return nil
	}
	return fmt.Errorf("unknown PluginExecutionLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PluginExecutionLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.plugin != nil {
		edges = append(edges, pluginexecutionlog.EdgePlugin)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PluginExecutionLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pluginexecutionlog.EdgePlugin:
		if id := m.plugin; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PluginExecutionLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PluginExecutionLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PluginExecutionLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedplugin {
		edges = append(edges, pluginexecutionlog.EdgePlugin)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PluginExecutionLogMutation) EdgeCleared(name string) bool {
	switch name {
	case pluginexecutionlog.EdgePlugin:
		return m.clearedplugin
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PluginExecutionLogMutation) ClearEdge(name string) error {
	switch name {
	case pluginexecutionlog.EdgePlugin:
		m.ClearPlugin()
		return nil
	}
	return fmt.Errorf("unknown PluginExecutionLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PluginExecutionLogMutation) ResetEdge(name string) error {
	switch name {
	case pluginexecutionlog.EdgePlugin:
		m.ResetPlugin()
		return nil
	}
	return fmt.Errorf("unknown PluginExecutionLog edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	username      *string
	password      *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int64) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}
