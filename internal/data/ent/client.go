// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/nuanxinqing123/QLToolsV2/internal/data/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/nuanxinqing123/QLToolsV2/internal/data/ent/cdkey"
	"github.com/nuanxinqing123/QLToolsV2/internal/data/ent/env"
	"github.com/nuanxinqing123/QLToolsV2/internal/data/ent/envplugin"
	"github.com/nuanxinqing123/QLToolsV2/internal/data/ent/loginhistory"
	"github.com/nuanxinqing123/QLToolsV2/internal/data/ent/panel"
	"github.com/nuanxinqing123/QLToolsV2/internal/data/ent/plugin"
	"github.com/nuanxinqing123/QLToolsV2/internal/data/ent/pluginexecutionlog"
	"github.com/nuanxinqing123/QLToolsV2/internal/data/ent/user"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// CdKey is the client for interacting with the CdKey builders.
	CdKey *CdKeyClient
	// Env is the client for interacting with the Env builders.
	Env *EnvClient
	// EnvPlugin is the client for interacting with the EnvPlugin builders.
	EnvPlugin *EnvPluginClient
	// LoginHistory is the client for interacting with the LoginHistory builders.
	LoginHistory *LoginHistoryClient
	// Panel is the client for interacting with the Panel builders.
	Panel *PanelClient
	// Plugin is the client for interacting with the Plugin builders.
	Plugin *PluginClient
	// PluginExecutionLog is the client for interacting with the PluginExecutionLog builders.
	PluginExecutionLog *PluginExecutionLogClient
	// User is the client for interacting with the User builders.
	User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.CdKey = NewCdKeyClient(c.config)
	c.Env = NewEnvClient(c.config)
	c.EnvPlugin = NewEnvPluginClient(c.config)
	c.LoginHistory = NewLoginHistoryClient(c.config)
	c.Panel = NewPanelClient(c.config)
	c.Plugin = NewPluginClient(c.config)
	c.PluginExecutionLog = NewPluginExecutionLogClient(c.config)
	c.User = NewUserClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                ctx,
		config:             cfg,
		CdKey:              NewCdKeyClient(cfg),
		Env:                NewEnvClient(cfg),
		EnvPlugin:          NewEnvPluginClient(cfg),
		LoginHistory:       NewLoginHistoryClient(cfg),
		Panel:              NewPanelClient(cfg),
		Plugin:             NewPluginClient(cfg),
		PluginExecutionLog: NewPluginExecutionLogClient(cfg),
		User:               NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                ctx,
		config:             cfg,
		CdKey:              NewCdKeyClient(cfg),
		Env:                NewEnvClient(cfg),
		EnvPlugin:          NewEnvPluginClient(cfg),
		LoginHistory:       NewLoginHistoryClient(cfg),
		Panel:              NewPanelClient(cfg),
		Plugin:             NewPluginClient(cfg),
		PluginExecutionLog: NewPluginExecutionLogClient(cfg),
		User:               NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		CdKey.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.CdKey, c.Env, c.EnvPlugin, c.LoginHistory, c.Panel, c.Plugin,
		c.PluginExecutionLog, c.User,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.CdKey, c.Env, c.EnvPlugin, c.LoginHistory, c.Panel, c.Plugin,
		c.PluginExecutionLog, c.User,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *CdKeyMutation:
		return c.CdKey.mutate(ctx, m)
	case *EnvMutation:
		return c.Env.mutate(ctx, m)
	case *EnvPluginMutation:
		return c.EnvPlugin.mutate(ctx, m)
	case *LoginHistoryMutation:
		return c.LoginHistory.mutate(ctx, m)
	case *PanelMutation:
		return c.Panel.mutate(ctx, m)
	case *PluginMutation:
		return c.Plugin.mutate(ctx, m)
	case *PluginExecutionLogMutation:
		return c.PluginExecutionLog.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// CdKeyClient is a client for the CdKey schema.
type CdKeyClient struct {
	config
}

// NewCdKeyClient returns a client for the CdKey from the given config.
func NewCdKeyClient(c config) *CdKeyClient {
	return &CdKeyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `cdkey.Hooks(f(g(h())))`.
func (c *CdKeyClient) Use(hooks ...Hook) {
	c.hooks.CdKey = append(c.hooks.CdKey, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `cdkey.Intercept(f(g(h())))`.
func (c *CdKeyClient) Intercept(interceptors ...Interceptor) {
	c.inters.CdKey = append(c.inters.CdKey, interceptors...)
}

// Create returns a builder for creating a CdKey entity.
func (c *CdKeyClient) Create() *CdKeyCreate {
	mutation := newCdKeyMutation(c.config, OpCreate)
	return &CdKeyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CdKey entities.
func (c *CdKeyClient) CreateBulk(builders ...*CdKeyCreate) *CdKeyCreateBulk {
	return &CdKeyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CdKeyClient) MapCreateBulk(slice any, setFunc func(*CdKeyCreate, int)) *CdKeyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CdKeyCreateBulk{err: fmt.Errorf("calling to CdKeyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CdKeyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CdKeyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CdKey.
func (c *CdKeyClient) Update() *CdKeyUpdate {
	mutation := newCdKeyMutation(c.config, OpUpdate)
	return &CdKeyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CdKeyClient) UpdateOne(_m *CdKey) *CdKeyUpdateOne {
	mutation := newCdKeyMutation(c.config, OpUpdateOne, withCdKey(_m))
	return &CdKeyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CdKeyClient) UpdateOneID(id int64) *CdKeyUpdateOne {
	mutation := newCdKeyMutation(c.config, OpUpdateOne, withCdKeyID(id))
	return &CdKeyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CdKey.
func (c *CdKeyClient) Delete() *CdKeyDelete {
	mutation := newCdKeyMutation(c.config, OpDelete)
	return &CdKeyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CdKeyClient) DeleteOne(_m *CdKey) *CdKeyDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CdKeyClient) DeleteOneID(id int64) *CdKeyDeleteOne {
	builder := c.Delete().Where(cdkey.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CdKeyDeleteOne{builder}
}

// Query returns a query builder for CdKey.
func (c *CdKeyClient) Query() *CdKeyQuery {
	return &CdKeyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCdKey},
		inters: c.Interceptors(),
	}
}

// Get returns a CdKey entity by its id.
func (c *CdKeyClient) Get(ctx context.Context, id int64) (*CdKey, error) {
	return c.Query().Where(cdkey.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CdKeyClient) GetX(ctx context.Context, id int64) *CdKey {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CdKeyClient) Hooks() []Hook {
	return c.hooks.CdKey
}

// Interceptors returns the client interceptors.
func (c *CdKeyClient) Interceptors() []Interceptor {
	return c.inters.CdKey
}

func (c *CdKeyClient) mutate(ctx context.Context, m *CdKeyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CdKeyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CdKeyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CdKeyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CdKeyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CdKey mutation op: %q", m.Op())
	}
}

// EnvClient is a client for the Env schema.
type EnvClient struct {
	config
}

// NewEnvClient returns a client for the Env from the given config.
func NewEnvClient(c config) *EnvClient {
	return &EnvClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `env.Hooks(f(g(h())))`.
func (c *EnvClient) Use(hooks ...Hook) {
	c.hooks.Env = append(c.hooks.Env, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `env.Intercept(f(g(h())))`.
func (c *EnvClient) Intercept(interceptors ...Interceptor) {
	c.inters.Env = append(c.inters.Env, interceptors...)
}

// Create returns a builder for creating a Env entity.
func (c *EnvClient) Create() *EnvCreate {
	mutation := newEnvMutation(c.config, OpCreate)
	return &EnvCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Env entities.
func (c *EnvClient) CreateBulk(builders ...*EnvCreate) *EnvCreateBulk {
	return &EnvCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EnvClient) MapCreateBulk(slice any, setFunc func(*EnvCreate, int)) *EnvCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EnvCreateBulk{err: fmt.Errorf("calling to EnvClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EnvCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EnvCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Env.
func (c *EnvClient) Update() *EnvUpdate {
	mutation := newEnvMutation(c.config, OpUpdate)
	return &EnvUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EnvClient) UpdateOne(_m *Env) *EnvUpdateOne {
	mutation := newEnvMutation(c.config, OpUpdateOne, withEnv(_m))
	return &EnvUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EnvClient) UpdateOneID(id int64) *EnvUpdateOne {
	mutation := newEnvMutation(c.config, OpUpdateOne, withEnvID(id))
	return &EnvUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Env.
func (c *EnvClient) Delete() *EnvDelete {
	mutation := newEnvMutation(c.config, OpDelete)
	return &EnvDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EnvClient) DeleteOne(_m *Env) *EnvDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EnvClient) DeleteOneID(id int64) *EnvDeleteOne {
	builder := c.Delete().Where(env.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EnvDeleteOne{builder}
}

// Query returns a query builder for Env.
func (c *EnvClient) Query() *EnvQuery {
	return &EnvQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEnv},
		inters: c.Interceptors(),
	}
}

// Get returns a Env entity by its id.
func (c *EnvClient) Get(ctx context.Context, id int64) (*Env, error) {
	return c.Query().Where(env.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EnvClient) GetX(ctx context.Context, id int64) *Env {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPanels queries the panels edge of a Env.
func (c *EnvClient) QueryPanels(_m *Env) *PanelQuery {
	query := (&PanelClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(env.Table, env.FieldID, id),
			sqlgraph.To(panel.Table, panel.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, env.PanelsTable, env.PanelsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvPlugins queries the env_plugins edge of a Env.
func (c *EnvClient) QueryEnvPlugins(_m *Env) *EnvPluginQuery {
	query := (&EnvPluginClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(env.Table, env.FieldID, id),
			sqlgraph.To(envplugin.Table, envplugin.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, env.EnvPluginsTable, env.EnvPluginsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EnvClient) Hooks() []Hook {
	return c.hooks.Env
}

// Interceptors returns the client interceptors.
func (c *EnvClient) Interceptors() []Interceptor {
	return c.inters.Env
}

func (c *EnvClient) mutate(ctx context.Context, m *EnvMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EnvCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EnvUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EnvUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EnvDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Env mutation op: %q", m.Op())
	}
}

// EnvPluginClient is a client for the EnvPlugin schema.
type EnvPluginClient struct {
	config
}

// NewEnvPluginClient returns a client for the EnvPlugin from the given config.
func NewEnvPluginClient(c config) *EnvPluginClient {
	return &EnvPluginClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `envplugin.Hooks(f(g(h())))`.
func (c *EnvPluginClient) Use(hooks ...Hook) {
	c.hooks.EnvPlugin = append(c.hooks.EnvPlugin, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `envplugin.Intercept(f(g(h())))`.
func (c *EnvPluginClient) Intercept(interceptors ...Interceptor) {
	c.inters.EnvPlugin = append(c.inters.EnvPlugin, interceptors...)
}

// Create returns a builder for creating a EnvPlugin entity.
func (c *EnvPluginClient) Create() *EnvPluginCreate {
	mutation := newEnvPluginMutation(c.config, OpCreate)
	return &EnvPluginCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EnvPlugin entities.
func (c *EnvPluginClient) CreateBulk(builders ...*EnvPluginCreate) *EnvPluginCreateBulk {
	return &EnvPluginCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EnvPluginClient) MapCreateBulk(slice any, setFunc func(*EnvPluginCreate, int)) *EnvPluginCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EnvPluginCreateBulk{err: fmt.Errorf("calling to EnvPluginClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EnvPluginCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EnvPluginCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EnvPlugin.
func (c *EnvPluginClient) Update() *EnvPluginUpdate {
	mutation := newEnvPluginMutation(c.config, OpUpdate)
	return &EnvPluginUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EnvPluginClient) UpdateOne(_m *EnvPlugin) *EnvPluginUpdateOne {
	mutation := newEnvPluginMutation(c.config, OpUpdateOne, withEnvPlugin(_m))
	return &EnvPluginUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EnvPluginClient) UpdateOneID(id int64) *EnvPluginUpdateOne {
	mutation := newEnvPluginMutation(c.config, OpUpdateOne, withEnvPluginID(id))
	return &EnvPluginUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EnvPlugin.
func (c *EnvPluginClient) Delete() *EnvPluginDelete {
	mutation := newEnvPluginMutation(c.config, OpDelete)
	return &EnvPluginDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EnvPluginClient) DeleteOne(_m *EnvPlugin) *EnvPluginDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EnvPluginClient) DeleteOneID(id int64) *EnvPluginDeleteOne {
	builder := c.Delete().Where(envplugin.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EnvPluginDeleteOne{builder}
}

// Query returns a query builder for EnvPlugin.
func (c *EnvPluginClient) Query() *EnvPluginQuery {
	return &EnvPluginQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEnvPlugin},
		inters: c.Interceptors(),
	}
}

// Get returns a EnvPlugin entity by its id.
func (c *EnvPluginClient) Get(ctx context.Context, id int64) (*EnvPlugin, error) {
	return c.Query().Where(envplugin.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EnvPluginClient) GetX(ctx context.Context, id int64) *EnvPlugin {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEnv queries the env edge of a EnvPlugin.
func (c *EnvPluginClient) QueryEnv(_m *EnvPlugin) *EnvQuery {
	query := (&EnvClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(envplugin.Table, envplugin.FieldID, id),
			sqlgraph.To(env.Table, env.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, envplugin.EnvTable, envplugin.EnvColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlugin queries the plugin edge of a EnvPlugin.
func (c *EnvPluginClient) QueryPlugin(_m *EnvPlugin) *PluginQuery {
	query := (&PluginClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(envplugin.Table, envplugin.FieldID, id),
			sqlgraph.To(plugin.Table, plugin.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, envplugin.PluginTable, envplugin.PluginColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EnvPluginClient) Hooks() []Hook {
	return c.hooks.EnvPlugin
}

// Interceptors returns the client interceptors.
func (c *EnvPluginClient) Interceptors() []Interceptor {
	return c.inters.EnvPlugin
}

func (c *EnvPluginClient) mutate(ctx context.Context, m *EnvPluginMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EnvPluginCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EnvPluginUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EnvPluginUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EnvPluginDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EnvPlugin mutation op: %q", m.Op())
	}
}

// LoginHistoryClient is a client for the LoginHistory schema.
type LoginHistoryClient struct {
	config
}

// NewLoginHistoryClient returns a client for the LoginHistory from the given config.
func NewLoginHistoryClient(c config) *LoginHistoryClient {
	return &LoginHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `loginhistory.Hooks(f(g(h())))`.
func (c *LoginHistoryClient) Use(hooks ...Hook) {
	c.hooks.LoginHistory = append(c.hooks.LoginHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `loginhistory.Intercept(f(g(h())))`.
func (c *LoginHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.LoginHistory = append(c.inters.LoginHistory, interceptors...)
}

// Create returns a builder for creating a LoginHistory entity.
func (c *LoginHistoryClient) Create() *LoginHistoryCreate {
	mutation := newLoginHistoryMutation(c.config, OpCreate)
	return &LoginHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LoginHistory entities.
func (c *LoginHistoryClient) CreateBulk(builders ...*LoginHistoryCreate) *LoginHistoryCreateBulk {
	return &LoginHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LoginHistoryClient) MapCreateBulk(slice any, setFunc func(*LoginHistoryCreate, int)) *LoginHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LoginHistoryCreateBulk{err: fmt.Errorf("calling to LoginHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LoginHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LoginHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LoginHistory.
func (c *LoginHistoryClient) Update() *LoginHistoryUpdate {
	mutation := newLoginHistoryMutation(c.config, OpUpdate)
	return &LoginHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LoginHistoryClient) UpdateOne(_m *LoginHistory) *LoginHistoryUpdateOne {
	mutation := newLoginHistoryMutation(c.config, OpUpdateOne, withLoginHistory(_m))
	return &LoginHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LoginHistoryClient) UpdateOneID(id int64) *LoginHistoryUpdateOne {
	mutation := newLoginHistoryMutation(c.config, OpUpdateOne, withLoginHistoryID(id))
	return &LoginHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LoginHistory.
func (c *LoginHistoryClient) Delete() *LoginHistoryDelete {
	mutation := newLoginHistoryMutation(c.config, OpDelete)
	return &LoginHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LoginHistoryClient) DeleteOne(_m *LoginHistory) *LoginHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LoginHistoryClient) DeleteOneID(id int64) *LoginHistoryDeleteOne {
	builder := c.Delete().Where(loginhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LoginHistoryDeleteOne{builder}
}

// Query returns a query builder for LoginHistory.
func (c *LoginHistoryClient) Query() *LoginHistoryQuery {
	return &LoginHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLoginHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a LoginHistory entity by its id.
func (c *LoginHistoryClient) Get(ctx context.Context, id int64) (*LoginHistory, error) {
	return c.Query().Where(loginhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LoginHistoryClient) GetX(ctx context.Context, id int64) *LoginHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *LoginHistoryClient) Hooks() []Hook {
	return c.hooks.LoginHistory
}

// Interceptors returns the client interceptors.
func (c *LoginHistoryClient) Interceptors() []Interceptor {
	return c.inters.LoginHistory
}

func (c *LoginHistoryClient) mutate(ctx context.Context, m *LoginHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LoginHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LoginHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LoginHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LoginHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown LoginHistory mutation op: %q", m.Op())
	}
}

// PanelClient is a client for the Panel schema.
type PanelClient struct {
	config
}

// NewPanelClient returns a client for the Panel from the given config.
func NewPanelClient(c config) *PanelClient {
	return &PanelClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `panel.Hooks(f(g(h())))`.
func (c *PanelClient) Use(hooks ...Hook) {
	c.hooks.Panel = append(c.hooks.Panel, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `panel.Intercept(f(g(h())))`.
func (c *PanelClient) Intercept(interceptors ...Interceptor) {
	c.inters.Panel = append(c.inters.Panel, interceptors...)
}

// Create returns a builder for creating a Panel entity.
func (c *PanelClient) Create() *PanelCreate {
	mutation := newPanelMutation(c.config, OpCreate)
	return &PanelCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Panel entities.
func (c *PanelClient) CreateBulk(builders ...*PanelCreate) *PanelCreateBulk {
	return &PanelCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PanelClient) MapCreateBulk(slice any, setFunc func(*PanelCreate, int)) *PanelCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PanelCreateBulk{err: fmt.Errorf("calling to PanelClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PanelCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PanelCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Panel.
func (c *PanelClient) Update() *PanelUpdate {
	mutation := newPanelMutation(c.config, OpUpdate)
	return &PanelUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PanelClient) UpdateOne(_m *Panel) *PanelUpdateOne {
	mutation := newPanelMutation(c.config, OpUpdateOne, withPanel(_m))
	return &PanelUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PanelClient) UpdateOneID(id int64) *PanelUpdateOne {
	mutation := newPanelMutation(c.config, OpUpdateOne, withPanelID(id))
	return &PanelUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Panel.
func (c *PanelClient) Delete() *PanelDelete {
	mutation := newPanelMutation(c.config, OpDelete)
	return &PanelDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PanelClient) DeleteOne(_m *Panel) *PanelDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PanelClient) DeleteOneID(id int64) *PanelDeleteOne {
	builder := c.Delete().Where(panel.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PanelDeleteOne{builder}
}

// Query returns a query builder for Panel.
func (c *PanelClient) Query() *PanelQuery {
	return &PanelQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePanel},
		inters: c.Interceptors(),
	}
}

// Get returns a Panel entity by its id.
func (c *PanelClient) Get(ctx context.Context, id int64) (*Panel, error) {
	return c.Query().Where(panel.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PanelClient) GetX(ctx context.Context, id int64) *Panel {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEnvs queries the envs edge of a Panel.
func (c *PanelClient) QueryEnvs(_m *Panel) *EnvQuery {
	query := (&EnvClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(panel.Table, panel.FieldID, id),
			sqlgraph.To(env.Table, env.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, panel.EnvsTable, panel.EnvsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PanelClient) Hooks() []Hook {
	return c.hooks.Panel
}

// Interceptors returns the client interceptors.
func (c *PanelClient) Interceptors() []Interceptor {
	return c.inters.Panel
}

func (c *PanelClient) mutate(ctx context.Context, m *PanelMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PanelCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PanelUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PanelUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PanelDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Panel mutation op: %q", m.Op())
	}
}

// PluginClient is a client for the Plugin schema.
type PluginClient struct {
	config
}

// NewPluginClient returns a client for the Plugin from the given config.
func NewPluginClient(c config) *PluginClient {
	return &PluginClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `plugin.Hooks(f(g(h())))`.
func (c *PluginClient) Use(hooks ...Hook) {
	c.hooks.Plugin = append(c.hooks.Plugin, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `plugin.Intercept(f(g(h())))`.
func (c *PluginClient) Intercept(interceptors ...Interceptor) {
	c.inters.Plugin = append(c.inters.Plugin, interceptors...)
}

// Create returns a builder for creating a Plugin entity.
func (c *PluginClient) Create() *PluginCreate {
	mutation := newPluginMutation(c.config, OpCreate)
	return &PluginCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Plugin entities.
func (c *PluginClient) CreateBulk(builders ...*PluginCreate) *PluginCreateBulk {
	return &PluginCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PluginClient) MapCreateBulk(slice any, setFunc func(*PluginCreate, int)) *PluginCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PluginCreateBulk{err: fmt.Errorf("calling to PluginClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PluginCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PluginCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Plugin.
func (c *PluginClient) Update() *PluginUpdate {
	mutation := newPluginMutation(c.config, OpUpdate)
	return &PluginUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PluginClient) UpdateOne(_m *Plugin) *PluginUpdateOne {
	mutation := newPluginMutation(c.config, OpUpdateOne, withPlugin(_m))
	return &PluginUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PluginClient) UpdateOneID(id int64) *PluginUpdateOne {
	mutation := newPluginMutation(c.config, OpUpdateOne, withPluginID(id))
	return &PluginUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Plugin.
func (c *PluginClient) Delete() *PluginDelete {
	mutation := newPluginMutation(c.config, OpDelete)
	return &PluginDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PluginClient) DeleteOne(_m *Plugin) *PluginDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PluginClient) DeleteOneID(id int64) *PluginDeleteOne {
	builder := c.Delete().Where(plugin.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PluginDeleteOne{builder}
}

// Query returns a query builder for Plugin.
func (c *PluginClient) Query() *PluginQuery {
	return &PluginQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePlugin},
		inters: c.Interceptors(),
	}
}

// Get returns a Plugin entity by its id.
func (c *PluginClient) Get(ctx context.Context, id int64) (*Plugin, error) {
	return c.Query().Where(plugin.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PluginClient) GetX(ctx context.Context, id int64) *Plugin {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEnvPlugins queries the env_plugins edge of a Plugin.
func (c *PluginClient) QueryEnvPlugins(_m *Plugin) *EnvPluginQuery {
	query := (&EnvPluginClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(plugin.Table, plugin.FieldID, id),
			sqlgraph.To(envplugin.Table, envplugin.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, plugin.EnvPluginsTable, plugin.EnvPluginsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExecutionLogs queries the execution_logs edge of a Plugin.
func (c *PluginClient) QueryExecutionLogs(_m *Plugin) *PluginExecutionLogQuery {
	query := (&PluginExecutionLogClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(plugin.Table, plugin.FieldID, id),
			sqlgraph.To(pluginexecutionlog.Table, pluginexecutionlog.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, plugin.ExecutionLogsTable, plugin.ExecutionLogsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PluginClient) Hooks() []Hook {
	return c.hooks.Plugin
}

// Interceptors returns the client interceptors.
func (c *PluginClient) Interceptors() []Interceptor {
	return c.inters.Plugin
}

func (c *PluginClient) mutate(ctx context.Context, m *PluginMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PluginCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PluginUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PluginUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PluginDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Plugin mutation op: %q", m.Op())
	}
}

// PluginExecutionLogClient is a client for the PluginExecutionLog schema.
type PluginExecutionLogClient struct {
	config
}

// NewPluginExecutionLogClient returns a client for the PluginExecutionLog from the given config.
func NewPluginExecutionLogClient(c config) *PluginExecutionLogClient {
	return &PluginExecutionLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `pluginexecutionlog.Hooks(f(g(h())))`.
func (c *PluginExecutionLogClient) Use(hooks ...Hook) {
	c.hooks.PluginExecutionLog = append(c.hooks.PluginExecutionLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `pluginexecutionlog.Intercept(f(g(h())))`.
func (c *PluginExecutionLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.PluginExecutionLog = append(c.inters.PluginExecutionLog, interceptors...)
}

// Create returns a builder for creating a PluginExecutionLog entity.
func (c *PluginExecutionLogClient) Create() *PluginExecutionLogCreate {
	mutation := newPluginExecutionLogMutation(c.config, OpCreate)
	return &PluginExecutionLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PluginExecutionLog entities.
func (c *PluginExecutionLogClient) CreateBulk(builders ...*PluginExecutionLogCreate) *PluginExecutionLogCreateBulk {
	return &PluginExecutionLogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PluginExecutionLogClient) MapCreateBulk(slice any, setFunc func(*PluginExecutionLogCreate, int)) *PluginExecutionLogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PluginExecutionLogCreateBulk{err: fmt.Errorf("calling to PluginExecutionLogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PluginExecutionLogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PluginExecutionLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PluginExecutionLog.
func (c *PluginExecutionLogClient) Update() *PluginExecutionLogUpdate {
	mutation := newPluginExecutionLogMutation(c.config, OpUpdate)
	return &PluginExecutionLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PluginExecutionLogClient) UpdateOne(_m *PluginExecutionLog) *PluginExecutionLogUpdateOne {
	mutation := newPluginExecutionLogMutation(c.config, OpUpdateOne, withPluginExecutionLog(_m))
	return &PluginExecutionLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PluginExecutionLogClient) UpdateOneID(id int64) *PluginExecutionLogUpdateOne {
	mutation := newPluginExecutionLogMutation(c.config, OpUpdateOne, withPluginExecutionLogID(id))
	return &PluginExecutionLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PluginExecutionLog.
func (c *PluginExecutionLogClient) Delete() *PluginExecutionLogDelete {
	mutation := newPluginExecutionLogMutation(c.config, OpDelete)
	return &PluginExecutionLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PluginExecutionLogClient) DeleteOne(_m *PluginExecutionLog) *PluginExecutionLogDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PluginExecutionLogClient) DeleteOneID(id int64) *PluginExecutionLogDeleteOne {
	builder := c.Delete().Where(pluginexecutionlog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PluginExecutionLogDeleteOne{builder}
}

// Query returns a query builder for PluginExecutionLog.
func (c *PluginExecutionLogClient) Query() *PluginExecutionLogQuery {
	return &PluginExecutionLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePluginExecutionLog},
		inters: c.Interceptors(),
	}
}

// Get returns a PluginExecutionLog entity by its id.
func (c *PluginExecutionLogClient) Get(ctx context.Context, id int64) (*PluginExecutionLog, error) {
	return c.Query().Where(pluginexecutionlog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PluginExecutionLogClient) GetX(ctx context.Context, id int64) *PluginExecutionLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPlugin queries the plugin edge of a PluginExecutionLog.
func (c *PluginExecutionLogClient) QueryPlugin(_m *PluginExecutionLog) *PluginQuery {
	query := (&PluginClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(pluginexecutionlog.Table, pluginexecutionlog.FieldID, id),
			sqlgraph.To(plugin.Table, plugin.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, pluginexecutionlog.PluginTable, pluginexecutionlog.PluginColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PluginExecutionLogClient) Hooks() []Hook {
	return c.hooks.PluginExecutionLog
}

// Interceptors returns the client interceptors.
func (c *PluginExecutionLogClient) Interceptors() []Interceptor {
	return c.inters.PluginExecutionLog
}

func (c *PluginExecutionLogClient) mutate(ctx context.Context, m *PluginExecutionLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PluginExecutionLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PluginExecutionLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PluginExecutionLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PluginExecutionLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PluginExecutionLog mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(_m *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(_m))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int64) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(_m *User) *UserDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int64) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int64) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int64) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		CdKey, Env, EnvPlugin, LoginHistory, Panel, Plugin, PluginExecutionLog,
		User []ent.Hook
	}
	inters struct {
		CdKey, Env, EnvPlugin, LoginHistory, Panel, Plugin, PluginExecutionLog,
		User []ent.Interceptor
	}
)
